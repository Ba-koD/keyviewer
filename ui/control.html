<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Key Viewer Control</title>
	<link rel="icon" href="/static/favicon.ico" type="image/x-icon" />
	<link rel="stylesheet" href="/static/control.css">
	<style>
		:root{
			--bg:#0b0c10; --panel:#12141a; --panel2:#181b22; --text:#eaeef5; --muted:#9aa4b2; --primary:#4f8cff; --border:#232734;
		}
		html,body{margin:0; font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial; background:var(--bg); color:var(--text)}
		.container{max-width:1000px; margin:24px auto; padding:0 16px}
		.h1{font-size:22px; font-weight:700; margin-bottom:12px}
		.panel{background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:16px; margin-bottom:16px}
		.row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
		label{color:var(--muted)}
		input, select, button{background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px 10px}
		button{cursor:pointer}
		button.primary{background:var(--primary); border-color:var(--primary)}
		table{width:100%; border-collapse:collapse; table-layout:fixed}
		th,td{border-bottom:1px solid var(--border); padding:8px 6px; text-align:left; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
		th.sortable{cursor:pointer; user-select:none}
		th .arrow{font-size:11px; color:var(--muted); margin-left:4px}
		.help{color:var(--muted); line-height:1.6}
		.badge{display:inline-block; background:#2a3040; color:#9ec1ff; border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px}
		.right{margin-left:auto}
		/* Modal */
		.modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,0.65); display:none; align-items:center; justify-content:center; z-index:999}
		.modal{width:560px; max-width:calc(100% - 32px); max-height:calc(100vh - 80px); background:#141821; border:1px solid #2a2f3a; border-radius:12px; padding:0; overflow:hidden; display:flex; flex-direction:column}
		.modal-header{padding:18px 18px 12px; border-bottom:1px solid #2a2f3a}
		.modal-header h3{margin:0; font-size:22px}
		.modal-content{flex:1; overflow-y:auto; padding:18px; scrollbar-width:none; -ms-overflow-style:none}
		.modal-content::-webkit-scrollbar{display:none}
		.modal-footer{padding:14px 18px; border-top:1px solid #2a2f3a}
		.modal .actions{display:flex; gap:10px; justify-content:space-between; margin:0}
		.modal .actions .spacer{flex:1}
		.modal .form-row{display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap}
		.modal .form-row > label{width:140px}
		.modal .form-row > .field{flex:1; min-width:160px}
		.danger{background:#ff5b5b; border-color:#ff5b5b}
		.modal button:disabled{opacity:0.5; filter:grayscale(30%); cursor:not-allowed}

		/* Color picker field */
		.color-field{display:flex; gap:8px; align-items:center}
		.color-field input[type="text"]{flex:1}
		button.pick{width:36px; height:36px; border:1px solid var(--border); border-radius:6px}
		input.picker-hidden{position:absolute; left:-9999px; width:0; height:0; opacity:0}

		/* Custom color palette popover */
		.color-popover{position:fixed; z-index:999999; background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:10px; box-shadow:0 6px 24px rgba(0,0,0,0.35); width:220px}
		.color-popover .swatches{display:grid; grid-template-columns:repeat(8, 1fr); gap:6px; margin-bottom:8px}
		.color-popover .swatch{width:22px; height:22px; border-radius:4px; border:1px solid rgba(255,255,255,0.18); cursor:pointer}
		.color-popover .row{display:flex; align-items:center; gap:6px; margin-bottom:8px}
		.color-popover input[type="text"]{flex:1; background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px; font-size:12px}
		.color-popover input[type="color"]{width:36px; height:28px; border:1px solid var(--border); border-radius:4px; background:transparent}
		.color-popover .actions{display:flex; gap:6px; justify-content:flex-end}
		.color-popover .btn{border:1px solid var(--border); background:var(--panel2); color:var(--text); border-radius:6px; padding:6px 10px; font-size:12px; cursor:pointer}

		/* Overlay preview inside modal */
		.overlay-preview{margin-top:12px; border:1px dashed #2a2f3a; border-radius:10px; padding:12px; background:#0f131b}
		.overlay-preview .queue{display:grid; grid-auto-rows:max-content; gap:var(--chip-gap, 8px)}
		.overlay-preview .chip{
			background: var(--chip-bg, rgba(0,0,0,0.6));
			color: var(--chip-fg, #fff);
			padding: var(--chip-pad-v, 10px) var(--chip-pad-h, 14px);
			border-radius: var(--chip-radius, 10px);
			font-size: var(--chip-font, 24px);
			font-weight: var(--chip-font-weight, 700);
			min-width:44px; text-align:center; user-select:none;
			transition: transform var(--fade-in, 120ms) ease, opacity var(--fade-in, 120ms) ease;
		}
		.overlay-preview .chip.hide{opacity:0; transform: translateY(8px); transition: transform var(--fade-out, 120ms) ease, opacity var(--fade-out, 120ms) ease}

		/* Image Crop Modal */
		.crop-container{position:relative; width:100%; max-height:400px; overflow:hidden; background:#000; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:move}
		.crop-canvas{max-width:100%; max-height:400px}
		.crop-overlay{position:absolute; top:0; left:0; pointer-events:none}
		.crop-info{margin-top:10px; font-size:12px; color:var(--muted)}
		.crop-controls{display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap}
		.crop-controls label{font-size:12px}
		.crop-controls input[type="range"]{flex:1; min-width:100px}
	</style>
</head>
<body>
	<div class="container">
		<div class="h1" id="title" data-text-ko="Key Queue Viewer ì„¤ì •" data-text-en="Key Queue Viewer Settings">Key Queue Viewer ì„¤ì •</div>

		<div class="panel">
			<div class="row">
				<div class="help" id="overlaySettingsLabel" data-text-ko="ì˜¤ë²„ë ˆì´ ì„¤ì •" data-text-en="Overlay Settings">ì˜¤ë²„ë ˆì´ ì„¤ì •</div>
				<button id="openOverlayCfg" class="right" data-text-ko="ì˜¤ë²„ë ˆì´ ì„¤ì •" data-text-en="Overlay Settings">ì˜¤ë²„ë ˆì´ ì„¤ì •</button>
			</div>
		</div>

		<div class="panel">
			<div class="help">
				<span class="badge" id="modeExplanationLabel" data-text-ko="ëª¨ë“œ ì„¤ëª…" data-text-en="Mode Explanation">ëª¨ë“œ ì„¤ëª…</span>
				<div id="modeExplanation1" data-text-ko="- ì œëª©: ìœˆë„ìš° ì œëª©ì— ê°’ì´ í¬í•¨ë˜ë©´ ë§¤ì¹­" data-text-en="- Title: Matches when window title contains the value">- ì œëª©: ìœˆë„ìš° ì œëª©ì— ê°’ì´ í¬í•¨ë˜ë©´ ë§¤ì¹­</div>
				<div id="modeExplanation2" data-text-ko="- í”„ë¡œì„¸ìŠ¤: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ ë§¤ì¹­ (ì˜ˆ: notepad.exe)" data-text-en="- Process: Must exactly match process name (e.g., notepad.exe)">- í”„ë¡œì„¸ìŠ¤: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ ë§¤ì¹­ (ì˜ˆ: notepad.exe)</div>
				<div id="modeExplanation3" data-text-ko="- HWND: íŠ¹ì • ì°½ í•¸ë“¤ê³¼ ì¼ì¹˜" data-text-en="- HWND: Matches specific window handle">- HWND: íŠ¹ì • ì°½ í•¸ë“¤ê³¼ ì¼ì¹˜</div>
				<div id="modeExplanation4" data-text-ko="- í´ë˜ìŠ¤: ìœˆë„ìš° í´ë˜ìŠ¤ëª…ê³¼ ì •í™•íˆ ì¼ì¹˜ (ë™ì¼ ìœ í˜•ì˜ ì°½ ì „ì²´)" data-text-en="- Class: Must exactly match window class name (all windows of same type)">- í´ë˜ìŠ¤: ìœˆë„ìš° í´ë˜ìŠ¤ëª…ê³¼ ì •í™•íˆ ì¼ì¹˜ (ë™ì¼ ìœ í˜•ì˜ ì°½ ì „ì²´)</div>
				<div id="modeExplanation5" data-text-ko="- ëª¨ë“  ì°½: ëª¨ë“  í¬ì»¤ìŠ¤ ì°½ì—ì„œ ì…ë ¥ì„ ê°ì§€" data-text-en="- All Windows: Detects input in all focused windows">- ëª¨ë“  ì°½: ëª¨ë“  í¬ì»¤ìŠ¤ ì°½ì—ì„œ ì…ë ¥ì„ ê°ì§€</div>
			</div>
		</div>

		<div class="panel">
			<div class="row">
				<label id="modeLabel" data-text-ko="ëª¨ë“œ" data-text-en="Mode">ëª¨ë“œ</label>
				<select id="mode">
					<option value="disabled" data-text-ko="ì‚¬ìš© ì•ˆ í•¨" data-text-en="Disabled">ì‚¬ìš© ì•ˆ í•¨</option>
					<option value="title" data-text-ko="ì œëª©(í¬í•¨)" data-text-en="Title (Contains)">ì œëª©(í¬í•¨)</option>
					<option value="process" selected data-text-ko="í”„ë¡œì„¸ìŠ¤(ì •í™•)" data-text-en="Process (Exact)">í”„ë¡œì„¸ìŠ¤(ì •í™•)</option>
					<option value="hwnd" data-text-ko="ìœˆë„ìš° í•¸ë“¤(HWND)" data-text-en="Window Handle (HWND)">ìœˆë„ìš° í•¸ë“¤(HWND)</option>
					<option value="class" data-text-ko="í´ë˜ìŠ¤ ëª…(ì •í™•)" data-text-en="Class Name (Exact)">í´ë˜ìŠ¤ ëª…(ì •í™•)</option>
					<option value="all" data-text-ko="ëª¨ë“  ì°½" data-text-en="All Windows">ëª¨ë“  ì°½</option>
				</select>
				<label id="valueSelectLabel" data-text-ko="ê°’ ì„ íƒ" data-text-en="Value Selection">ê°’ ì„ íƒ</label>
				<select id="valuePick" style="min-width:220px"><option value="" data-text-ko="ì„ íƒ..." data-text-en="Select...">ì„ íƒ...</option></select>
				<button id="apply" class="primary" data-text-ko="ì ìš©" data-text-en="Apply">ì ìš©</button>
				<div id="status" class="right help"></div>
			</div>
			<div class="help" style="margin-top:8px; padding:8px; background:var(--panel2); border-radius:6px;">
				<strong id="currentSelectionLabel" data-text-ko="í˜„ì¬ ì„ íƒ ìƒíƒœ:" data-text-en="Current Selection Status:">í˜„ì¬ ì„ íƒ ìƒíƒœ:</strong><br>
				<span id="modeStatusLabel" data-text-ko="ëª¨ë“œ:" data-text-en="Mode:">ëª¨ë“œ:</span> <span id="debugMode" class="badge">-</span><br>
				<span id="selectedValueLabel" data-text-ko="ì €ì¥ëœ ê°’:" data-text-en="Saved Value:">ì €ì¥ëœ ê°’:</span> <span id="debugValue" class="badge">-</span><br>
				<span id="applyStatusLabel" data-text-ko="ì ìš© ìƒíƒœ:" data-text-en="Apply Status:">ì ìš© ìƒíƒœ:</span> <span id="debugStatus" class="badge">-</span>
			</div>
		</div>

		<div class="panel">
			<div class="row" style="margin-bottom:8px">
				<div class="help" id="currentFocusLabel" data-text-ko="í˜„ì¬ í¬ì»¤ìŠ¤ ì°½" data-text-en="Current Focus Window">í˜„ì¬ í¬ì»¤ìŠ¤ ì°½</div>
			</div>
			<div class="help" id="fginfo" data-text-ko="ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘..." data-text-en="Loading...">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
		</div>

		<div class="panel">
			<div class="row" style="margin-bottom:8px">
				<div class="help" id="openWindowsLabel" data-text-ko="í˜„ì¬ ì—´ë ¤ìˆëŠ” ì°½ (ì„ íƒí•˜ë©´ ì ìš©ë¨)" data-text-en="Currently Open Windows (Click to apply)">í˜„ì¬ ì—´ë ¤ìˆëŠ” ì°½ (ì„ íƒí•˜ë©´ ì ìš©ë¨)</div>
			</div>
			<table>
				<colgroup>
					<col style="width:46%"/>
					<col style="width:18%"/>
					<col style="width:12%"/>
					<col style="width:16%"/>
				</colgroup>
				<thead>
					<tr>
						<th id="th_title" data-key="title" class="sortable" data-text-ko="ì œëª©" data-text-en="Title">ì œëª© <span class="arrow" id="arrow_title"></span></th>
						<th id="th_process" data-key="process" class="sortable" data-text-ko="í”„ë¡œì„¸ìŠ¤" data-text-en="Process">í”„ë¡œì„¸ìŠ¤ <span class="arrow" id="arrow_process"></span></th>
						<th id="th_hwnd" data-key="hwnd" class="sortable" data-text-ko="HWND" data-text-en="HWND">HWND <span class="arrow" id="arrow_hwnd"></span></th>
						<th id="th_class" data-key="class" class="sortable" data-text-ko="í´ë˜ìŠ¤" data-text-en="Class">í´ë˜ìŠ¤ <span class="arrow" id="arrow_class"></span></th>
					</tr>
				</thead>
				<tbody id="winTableBody"></tbody>
			</table>
		</div>
	</div>

	<div class="modal-backdrop" id="modalAll">
		<div class="modal">
			<div class="modal-header">
				<h3 id="warningTitle" data-text-ko="ì£¼ì˜!" data-text-en="Warning!">ì£¼ì˜!</h3>
			</div>
			<div class="modal-content">
				<p style="font-size:18px; line-height:1.5" id="warningMessage" data-text-ko="í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ë©´ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì—ì„œ ì˜¤ë²„ë ˆì´ê°€ ì‘ë™í•´ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤!" data-text-en="Using this feature may cause overlay to work during password input, which could cause problems!">í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ë©´ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì—ì„œ ì˜¤ë²„ë ˆì´ê°€ ì‘ë™í•´ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤!</p>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="saveAll" class="danger" disabled data-text-ko="í™œì„±í™”" data-text-en="Activate">í™œì„±í™”</button>
					<span class="spacer"></span>
					<button id="cancelAll" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Key Image Settings Modal -->
	<div class="modal-backdrop" id="modalKeyImage">
		<div class="modal" style="width:700px">
			<div class="modal-header">
				<h3 id="keyImageTitle" data-text-ko="í‚¤ ì´ë¯¸ì§€ ì„¤ì •" data-text-en="Key Image Settings">í‚¤ ì´ë¯¸ì§€ ì„¤ì •</h3>
			</div>
			<div class="modal-content">
				<!-- Global Settings -->
				<div style="margin-bottom:16px; padding:12px; background:var(--panel2); border-radius:8px">
					<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸŒ ì „ì²´ ì„¤ì •" data-text-en="ğŸŒ Global Settings">ğŸŒ ì „ì²´ ì„¤ì •</div>
					<div class="form-row">
						<label data-text-ko="ê¸°ë³¸ ì´ë¯¸ì§€" data-text-en="Default Image">ê¸°ë³¸ ì´ë¯¸ì§€</label>
						<div class="field" style="display:flex; gap:8px; align-items:center">
							<input type="file" id="ki_default_img" accept="image/*" style="flex:1"/>
							<button id="ki_default_clear" class="danger" style="padding:6px 10px; font-size:12px" data-text-ko="ì‚­ì œ" data-text-en="Remove">ì‚­ì œ</button>
						</div>
					</div>
					<div class="form-row">
						<label data-text-ko="ê¸°ë³¸ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide Text by Default">ê¸°ë³¸ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</label>
						<div class="field"><input type="checkbox" id="ki_default_hide"/> <span class="help" data-text-ko="ì²´í¬í•˜ë©´ ëª¨ë“  í‚¤ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Check to hide all key text">ì²´í¬í•˜ë©´ ëª¨ë“  í‚¤ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</span></div>
					</div>
					<div id="ki_default_preview" style="margin-top:8px; display:none">
						<span style="font-size:12px; opacity:0.7" data-text-ko="ë¯¸ë¦¬ë³´ê¸°:" data-text-en="Preview:">ë¯¸ë¦¬ë³´ê¸°:</span>
						<img id="ki_default_preview_img" style="max-height:48px; max-width:100px; border-radius:6px; vertical-align:middle; margin-left:8px"/>
					</div>
				</div>

				<!-- Per-Key Settings -->
				<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸ¹ ê°œë³„ í‚¤ ì„¤ì •" data-text-en="ğŸ¹ Per-Key Settings">ğŸ¹ ê°œë³„ í‚¤ ì„¤ì •</div>
				<div class="form-row">
					<label data-text-ko="í‚¤ ì„ íƒ" data-text-en="Select Key">í‚¤ ì„ íƒ</label>
					<select id="ki_key_select" class="field" style="min-width:120px">
						<option value="">-- í‚¤ ì„ íƒ --</option>
					</select>
					<button id="ki_add_custom" style="padding:6px 12px" data-text-ko="+ ì§ì ‘ ì…ë ¥" data-text-en="+ Custom">+ ì§ì ‘ ì…ë ¥</button>
				</div>
				
				<div id="ki_key_config" style="display:none; margin-top:12px; padding:12px; background:var(--panel2); border-radius:8px">
					<div style="font-weight:600; margin-bottom:10px"><span data-text-ko="í‚¤:" data-text-en="Key:">í‚¤:</span> <span id="ki_selected_key" class="badge"></span></div>
					<div class="form-row">
						<label data-text-ko="ì´ë¯¸ì§€" data-text-en="Image">ì´ë¯¸ì§€</label>
						<div class="field" style="display:flex; gap:8px; align-items:center">
							<input type="file" id="ki_key_img" accept="image/*" style="flex:1"/>
							<button id="ki_key_clear" class="danger" style="padding:6px 10px; font-size:12px" data-text-ko="ì‚­ì œ" data-text-en="Remove">ì‚­ì œ</button>
						</div>
					</div>
					<div class="form-row">
						<label data-text-ko="í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide Text">í…ìŠ¤íŠ¸ ìˆ¨ê¹€</label>
						<div class="field"><input type="checkbox" id="ki_key_hide"/> <span class="help" data-text-ko="ì´ í‚¤ë§Œ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide text for this key only">ì´ í‚¤ë§Œ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</span></div>
					</div>
					<div id="ki_key_preview" style="margin-top:8px; display:none">
						<span style="font-size:12px; opacity:0.7" data-text-ko="ë¯¸ë¦¬ë³´ê¸°:" data-text-en="Preview:">ë¯¸ë¦¬ë³´ê¸°:</span>
						<img id="ki_key_preview_img" style="max-height:48px; max-width:100px; border-radius:6px; vertical-align:middle; margin-left:8px"/>
					</div>
					<button id="ki_key_save" class="primary" style="margin-top:10px" data-text-ko="ì´ í‚¤ ì €ì¥" data-text-en="Save This Key">ì´ í‚¤ ì €ì¥</button>
				</div>

				<!-- Configured Keys List -->
				<div style="margin-top:16px">
					<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸ“‹ ì„¤ì •ëœ í‚¤ ëª©ë¡" data-text-en="ğŸ“‹ Configured Keys">ğŸ“‹ ì„¤ì •ëœ í‚¤ ëª©ë¡</div>
					<div id="ki_configured_list" style="max-height:200px; overflow-y:auto; background:var(--panel2); border-radius:8px; padding:8px">
						<div class="help" style="text-align:center; padding:20px" data-text-ko="ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤" data-text-en="No keys configured">ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤</div>
					</div>
				</div>

				<!-- Preview -->
				<div class="overlay-preview" style="margin-top:16px">
					<div class="help" style="margin-bottom:8px" data-text-ko="ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°" data-text-en="Live Preview">ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°</div>
					<div class="queue" id="ki_preview_queue" style="display:grid; grid-template-columns:repeat(4, max-content); gap:8px"></div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="ki_clear_all" class="danger" data-text-ko="ì „ì²´ ì´ˆê¸°í™”" data-text-en="Clear All">ì „ì²´ ì´ˆê¸°í™”</button>
					<span class="spacer"></span>
					<button id="closeKeyImage" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Image Crop Modal -->
	<div class="modal-backdrop" id="modalCrop" style="z-index:1001">
		<div class="modal" style="width:600px">
			<div class="modal-header">
				<h3 data-text-ko="ì´ë¯¸ì§€ ìë¥´ê¸°" data-text-en="Crop Image">ì´ë¯¸ì§€ ìë¥´ê¸°</h3>
			</div>
			<div class="modal-content">
				<div class="crop-container" id="cropContainer">
					<canvas id="cropCanvas" class="crop-canvas"></canvas>
					<canvas id="cropOverlay" class="crop-overlay"></canvas>
				</div>
				<div class="crop-info" id="cropInfo" data-text-ko="ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •, íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ" data-text-en="Drag to position, scroll to zoom">ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •, íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ</div>
				<div class="crop-controls">
					<label data-text-ko="í™•ëŒ€/ì¶•ì†Œ:" data-text-en="Zoom:">í™•ëŒ€/ì¶•ì†Œ:</label>
					<input type="range" id="cropZoom" min="0.5" max="3" step="0.1" value="1"/>
					<span id="cropZoomValue">100%</span>
				</div>
				<div class="crop-controls">
					<span style="font-size:12px; opacity:0.7" data-text-ko="ì¹© í¬ê¸° (ì˜¤ë²„ë ˆì´ ì„¤ì • ê¸°ì¤€):" data-text-en="Chip size (from overlay settings):">ì¹© í¬ê¸° (ì˜¤ë²„ë ˆì´ ì„¤ì • ê¸°ì¤€):</span>
					<span id="cropChipSize" class="badge">-- x -- px</span>
				</div>
				<div style="margin-top:12px; padding:10px; background:var(--panel2); border-radius:8px">
					<div style="font-size:12px; opacity:0.7; margin-bottom:8px" data-text-ko="ğŸ’¡ ì°¸ê³ : ê¸´ í‚¤(SPACE, ENTER ë“±)ë„ ê°™ì€ ì´ë¯¸ì§€ê°€ ì ìš©ë©ë‹ˆë‹¤" data-text-en="ğŸ’¡ Note: Longer keys (SPACE, ENTER, etc.) will use the same image">ğŸ’¡ ì°¸ê³ : ê¸´ í‚¤(SPACE, ENTER ë“±)ë„ ê°™ì€ ì´ë¯¸ì§€ê°€ ì ìš©ë©ë‹ˆë‹¤</div>
					<div style="display:flex; gap:8px; flex-wrap:wrap">
						<div class="badge" style="padding:6px 12px">Q</div>
						<div class="badge" style="padding:6px 24px">SPACE</div>
						<div class="badge" style="padding:6px 18px">ENTER</div>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="cropApply" class="primary" data-text-ko="ì ìš©" data-text-en="Apply">ì ìš©</button>
					<span class="spacer"></span>
					<button id="cropCancel" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
				</div>
			</div>
		</div>
	</div>

	<div class="modal-backdrop" id="modalOverlay">
		<div class="modal">
			<div class="modal-header">
				<h3 id="overlaySettingsTitle" data-text-ko="ì˜¤ë²„ë ˆì´ ì„¤ì •" data-text-en="Overlay Settings">ì˜¤ë²„ë ˆì´ ì„¤ì •</h3>
			</div>
			<div class="modal-content">
				<div class="form-row"><label id="fadeInLabel" data-text-ko="Fade In(ms)" data-text-en="Fade In(ms)">Fade In(ms)</label><input id="ov_fade_in" class="field" type="number" min="0" step="10"/></div>
				<div class="form-row"><label id="fadeOutLabel" data-text-ko="Fade Out(ms)" data-text-en="Fade Out(ms)">Fade Out(ms)</label><input id="ov_fade_out" class="field" type="number" min="0" step="10"/></div>
				<div class="form-row"><label id="bgColorLabel" data-text-ko="ë°°ê²½ìƒ‰(ì „ì²´)" data-text-en="Background Color (Overall)">ë°°ê²½ìƒ‰(ì „ì²´)</label><div class="field color-field"><input id="ov_bg" type="text" placeholder="#000000"/><button id="ov_bg_pick" class="pick" title="ìƒ‰ ì„ íƒ" data-title-ko="ìƒ‰ ì„ íƒ" data-title-en="Color Picker"></button><input id="ov_bg_picker" type="color" class="picker-hidden"/></div></div>
				<div class="form-row"><label id="transparentBgLabel" data-text-ko="íˆ¬ëª… ë°°ê²½" data-text-en="Transparent Background">íˆ¬ëª… ë°°ê²½</label><input id="ov_bg_trans" type="checkbox"/> <span class="help" id="transparentBgHelp" data-text-ko="ì²´í¬í•˜ë©´ ë°°ê²½ì´ ì™„ì „ íˆ¬ëª…" data-text-en="Check to make background completely transparent">ì²´í¬í•˜ë©´ ë°°ê²½ì´ ì™„ì „ íˆ¬ëª…</span></div>
				<div class="form-row"><label id="chipBgLabel" data-text-ko="ì¹© ë°°ê²½ìƒ‰" data-text-en="Chip Background Color">ì¹© ë°°ê²½ìƒ‰</label><div class="field color-field"><input id="ov_chip_bg" type="text" placeholder="#000000"/><button id="ov_chip_bg_pick" class="pick" title="ìƒ‰ ì„ íƒ" data-title-ko="ìƒ‰ ì„ íƒ" data-title-en="Color Picker"></button><input id="ov_chip_bg_picker" type="color" class="picker-hidden"/></div></div>
				<div class="form-row"><label id="textColorLabel" data-text-ko="í…ìŠ¤íŠ¸ ìƒ‰" data-text-en="Text Color">í…ìŠ¤íŠ¸ ìƒ‰</label><div class="field color-field"><input id="ov_chip_fg" type="text" placeholder="#ffffff"/><button id="ov_chip_fg_pick" class="pick" title="ìƒ‰ ì„ íƒ" data-title-ko="ìƒ‰ ì„ íƒ" data-title-en="Color Picker"></button><input id="ov_chip_fg_picker" type="color" class="picker-hidden"/></div></div>
				<div class="form-row"><label id="chipGapLabel" data-text-ko="ì¹© ê°„ê²©(px)" data-text-en="Chip Gap(px)">ì¹© ê°„ê²©(px)</label><input id="ov_gap" class="field" type="number" min="0" step="1"/></div>
				<div class="form-row"><label id="padVLabel" data-text-ko="ì„¸ë¡œ íŒ¨ë”©(px)" data-text-en="Vertical Padding(px)">ì„¸ë¡œ íŒ¨ë”©(px)</label><input id="ov_pad_v" class="field" type="number" min="0" step="1"/></div>
				<div class="form-row"><label id="padHLabel" data-text-ko="ê°€ë¡œ íŒ¨ë”©(px)" data-text-en="Horizontal Padding(px)">ê°€ë¡œ íŒ¨ë”©(px)</label><input id="ov_pad_h" class="field" type="number" min="0" step="1"/></div>
				<div class="form-row"><label id="radiusLabel" data-text-ko="ëª¨ì„œë¦¬(px)" data-text-en="Corner Radius(px)">ëª¨ì„œë¦¬(px)</label><input id="ov_radius" class="field" type="number" min="0" step="1"/></div>
				<div class="form-row"><label id="fontSizeLabel" data-text-ko="í°íŠ¸(px)" data-text-en="Font Size(px)">í°íŠ¸(px)</label><input id="ov_font_px" class="field" type="number" min="8" step="1"/></div>
				<div class="form-row"><label id="fontWeightLabel" data-text-ko="í°íŠ¸ ë‘ê»˜" data-text-en="Font Weight">í°íŠ¸ ë‘ê»˜</label><input id="ov_font_w" class="field" type="number" min="100" step="50"/></div>
				<div class="form-row"><label id="colsLabel" data-text-ko="ì—´(Cols)" data-text-en="Columns(Cols)">ì—´(Cols)</label><input id="ov_cols" class="field" type="number" min="1" step="1"/></div>
				<div class="form-row"><label id="rowsLabel" data-text-ko="í–‰(Rows)" data-text-en="Rows">í–‰(Rows)</label><input id="ov_rows" class="field" type="number" min="0" step="1"/></div>
				<div class="help" id="rowsHelp" data-text-ko="í–‰(Rows)ì— 0ì„ ì…ë ¥í•˜ë©´ ì œí•œ ì—†ì´ ì—¬ëŸ¬ ì¤„ë¡œ ìë™ ê°ìŒ‰ë‹ˆë‹¤." data-text-en="Enter 0 in Rows to automatically wrap to multiple lines without limit.">í–‰(Rows)ì— 0ì„ ì…ë ¥í•˜ë©´ ì œí•œ ì—†ì´ ì—¬ëŸ¬ ì¤„ë¡œ ìë™ ê°ìŒ‰ë‹ˆë‹¤.</div>
				<div class="form-row"><label id="alignLabel" data-text-ko="ì •ë ¬" data-text-en="Alignment">ì •ë ¬</label><select id="ov_align" class="field"><option value="left" selected data-text-ko="ì¢Œì¸¡" data-text-en="Left">ì¢Œì¸¡</option><option value="center" data-text-ko="ì¤‘ì•™" data-text-en="Center">ì¤‘ì•™</option><option value="right" data-text-ko="ìš°ì¸¡" data-text-en="Right">ìš°ì¸¡</option></select></div>
				<div class="form-row"><label id="directionLabel" data-text-ko="ìŒ“ì´ëŠ” ë°©í–¥" data-text-en="Stacking Direction">ìŒ“ì´ëŠ” ë°©í–¥</label><select id="ov_direction" class="field"><option value="ltr" selected data-text-ko="ì™¼â†’ì˜¤ (LTR)" data-text-en="Leftâ†’Right (LTR)">ì™¼â†’ì˜¤ (LTR)</option><option value="rtl" data-text-ko="ì˜¤â†’ì™¼ (RTL)" data-text-en="Rightâ†’Left (RTL)">ì˜¤â†’ì™¼ (RTL)</option></select></div>

				<div style="margin-top:12px; padding:12px; background:var(--panel2); border-radius:8px">
					<div class="form-row" style="margin-bottom:0">
						<label data-text-ko="ğŸ–¼ï¸ í‚¤ ì´ë¯¸ì§€" data-text-en="ğŸ–¼ï¸ Key Images">ğŸ–¼ï¸ í‚¤ ì´ë¯¸ì§€</label>
						<button id="ov_open_key_image" class="field" style="flex:none; padding:8px 16px" data-text-ko="í‚¤ ì´ë¯¸ì§€ ì„¤ì • ì—´ê¸°" data-text-en="Open Key Image Settings">í‚¤ ì´ë¯¸ì§€ ì„¤ì • ì—´ê¸°</button>
					</div>
				</div>

				<div class="overlay-preview" id="ov_preview">
					<div class="help" style="margin-bottom:8px" id="previewLabel" data-text-ko="ë¯¸ë¦¬ë³´ê¸°" data-text-en="Preview">ë¯¸ë¦¬ë³´ê¸°</div>
					<div class="queue" id="ov_preview_queue"></div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="saveOverlay" class="primary" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
					<span class="spacer"></span>
					<button id="closeOverlay" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<script>
	(async function(){
		const modeEl = document.getElementById('mode');
		const statusEl = document.getElementById('status');
		const listEl = null;
		const fginfoEl = document.getElementById('fginfo');
		const valuePick = document.getElementById('valuePick');
		let lastWindows = [];
		const winTableBody = document.getElementById('winTableBody');
		let sortKey = 'process';
		let sortDir = 'asc'; // 'asc' | 'desc'
		const headerMap = {
			title: document.getElementById('th_title'),
			process: document.getElementById('th_process'),
			hwnd: document.getElementById('th_hwnd'),
			class: document.getElementById('th_class')
		};
		const arrowMap = {
			title: document.getElementById('arrow_title'),
			process: document.getElementById('arrow_process'),
			hwnd: document.getElementById('arrow_hwnd'),
			class: document.getElementById('arrow_class')
		};

		// =============================================
		// Key Image Settings (localStorage based)
		// =============================================
		const STORAGE_KEY_IMAGES = 'kv_key_images';
		const STORAGE_KEY_HIDE = 'kv_hide_key_text';

		// Common key labels for dropdown
		const COMMON_KEYS = [
			'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
			'0','1','2','3','4','5','6','7','8','9',
			'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
			'ESC','TAB','CAPS','LSHIFT','RSHIFT','LCTRL','RCTRL','LALT','RALT',
			'LCMD','RCMD','LOPT','ROPT','LWIN','RWIN','LSUPER','RSUPER',
			'SPACE','ENTER','BACKSPACE','DELETE','INSERT','HOME','END','PAGEUP','PAGEDOWN',
			'UP','DOWN','LEFT','RIGHT','FN',
			'NUM0','NUM1','NUM2','NUM3','NUM4','NUM5','NUM6','NUM7','NUM8','NUM9',
			'NUMLOCK','NUMENTER','NUMADD','NUMSUB','NUMMUL','NUMDIV','NUMDOT',
			'-','=','[',']','\\',';','\'',',','.','/','`'
		];

		function getKeyImages() {
			try { return JSON.parse(localStorage.getItem(STORAGE_KEY_IMAGES) || '{}'); } catch(e) { return {}; }
		}
		function setKeyImages(data) {
			localStorage.setItem(STORAGE_KEY_IMAGES, JSON.stringify(data));
		}
		function getHideKeyText() {
			try { return JSON.parse(localStorage.getItem(STORAGE_KEY_HIDE) || '{}'); } catch(e) { return {}; }
		}
		function setHideKeyText(data) {
			localStorage.setItem(STORAGE_KEY_HIDE, JSON.stringify(data));
		}

		function fileToBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file);
			});
		}

		// =============================================
		// Image Crop Functionality
		// =============================================
		const modalCrop = document.getElementById('modalCrop');
		const cropCanvas = document.getElementById('cropCanvas');
		const cropOverlay = document.getElementById('cropOverlay');
		const cropContainer = document.getElementById('cropContainer');
		const cropZoom = document.getElementById('cropZoom');
		const cropZoomValue = document.getElementById('cropZoomValue');
		const cropChipSizeEl = document.getElementById('cropChipSize');
		const cropApply = document.getElementById('cropApply');
		const cropCancel = document.getElementById('cropCancel');

		let cropImage = null;
		let cropState = { x: 0, y: 0, zoom: 1, dragging: false, startX: 0, startY: 0 };
		let cropCallback = null;
		let cropTargetKey = null;
		let cropChipW = 80;
		let cropChipH = 50;

		async function loadChipSizeFromOverlay() {
			try {
				const res = await fetch('/api/overlay-config');
				const cfg = await res.json();
				// Calculate chip size from overlay settings
				const fontPx = cfg.chip_font_px || 24;
				const padV = cfg.chip_pad_v || 10;
				const padH = cfg.chip_pad_h || 14;
				cropChipH = fontPx + (padV * 2);
				// Add extra width (1.5x) to accommodate longer keys like SPACE
				cropChipW = Math.max(60, Math.round((fontPx * 2 + (padH * 2)) * 1.5));
				cropChipSizeEl.textContent = `${cropChipW} x ${cropChipH} px`;
			} catch (e) {
				cropChipW = 100;
				cropChipH = 50;
				cropChipSizeEl.textContent = `${cropChipW} x ${cropChipH} px`;
			}
		}

		async function openCropModal(imageSrc, targetKey, callback) {
			cropCallback = callback;
			cropTargetKey = targetKey;
			cropState = { x: 0, y: 0, zoom: 1, dragging: false, startX: 0, startY: 0 };
			cropZoom.value = 1;
			cropZoomValue.textContent = '100%';
			
			// Load chip size from overlay settings
			await loadChipSizeFromOverlay();
			
			cropImage = new Image();
			cropImage.onload = () => {
				modalCrop.style.display = 'flex';
				requestAnimationFrame(renderCrop);
			};
			cropImage.src = imageSrc;
		}

		function closeCropModal() {
			modalCrop.style.display = 'none';
			cropImage = null;
			cropCallback = null;
		}

		function renderCrop() {
			if (!cropImage) return;
			
			const chipW = cropChipW;
			const chipH = cropChipH;
			const containerW = cropContainer.clientWidth;
			const containerH = 400;
			
			// Set canvas size
			cropCanvas.width = containerW;
			cropCanvas.height = containerH;
			cropOverlay.width = containerW;
			cropOverlay.height = containerH;
			cropOverlay.style.width = containerW + 'px';
			cropOverlay.style.height = containerH + 'px';
			
			const ctx = cropCanvas.getContext('2d');
			const ovCtx = cropOverlay.getContext('2d');
			
			// Clear
			ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, containerW, containerH);
			
			// Draw image with zoom and offset
			const imgW = cropImage.width * cropState.zoom;
			const imgH = cropImage.height * cropState.zoom;
			const imgX = (containerW - imgW) / 2 + cropState.x;
			const imgY = (containerH - imgH) / 2 + cropState.y;
			ctx.drawImage(cropImage, imgX, imgY, imgW, imgH);
			
			// Draw overlay (dark outside chip area)
			ovCtx.clearRect(0, 0, containerW, containerH);
			ovCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
			ovCtx.fillRect(0, 0, containerW, containerH);
			
			// Clear chip area (transparent hole)
			const chipX = (containerW - chipW) / 2;
			const chipY = (containerH - chipH) / 2;
			ovCtx.clearRect(chipX, chipY, chipW, chipH);
			
			// Draw chip border
			ovCtx.strokeStyle = '#4f8cff';
			ovCtx.lineWidth = 2;
			ovCtx.strokeRect(chipX, chipY, chipW, chipH);
			
			// Draw chip corners
			const cornerSize = 10;
			ovCtx.strokeStyle = '#fff';
			ovCtx.lineWidth = 3;
			// Top-left
			ovCtx.beginPath(); ovCtx.moveTo(chipX, chipY + cornerSize); ovCtx.lineTo(chipX, chipY); ovCtx.lineTo(chipX + cornerSize, chipY); ovCtx.stroke();
			// Top-right
			ovCtx.beginPath(); ovCtx.moveTo(chipX + chipW - cornerSize, chipY); ovCtx.lineTo(chipX + chipW, chipY); ovCtx.lineTo(chipX + chipW, chipY + cornerSize); ovCtx.stroke();
			// Bottom-left
			ovCtx.beginPath(); ovCtx.moveTo(chipX, chipY + chipH - cornerSize); ovCtx.lineTo(chipX, chipY + chipH); ovCtx.lineTo(chipX + cornerSize, chipY + chipH); ovCtx.stroke();
			// Bottom-right
			ovCtx.beginPath(); ovCtx.moveTo(chipX + chipW - cornerSize, chipY + chipH); ovCtx.lineTo(chipX + chipW, chipY + chipH); ovCtx.lineTo(chipX + chipW, chipY + chipH - cornerSize); ovCtx.stroke();
		}

		function getCroppedImage() {
			if (!cropImage) return null;
			
			const chipW = cropChipW;
			const chipH = cropChipH;
			const containerW = cropCanvas.width;
			const containerH = cropCanvas.height;
			
			// Calculate crop area in image coordinates
			const imgW = cropImage.width * cropState.zoom;
			const imgH = cropImage.height * cropState.zoom;
			const imgX = (containerW - imgW) / 2 + cropState.x;
			const imgY = (containerH - imgH) / 2 + cropState.y;
			
			const chipX = (containerW - chipW) / 2;
			const chipY = (containerH - chipH) / 2;
			
			// Convert chip coordinates to source image coordinates
			const srcX = (chipX - imgX) / cropState.zoom;
			const srcY = (chipY - imgY) / cropState.zoom;
			const srcW = chipW / cropState.zoom;
			const srcH = chipH / cropState.zoom;
			
			// Create output canvas
			const outCanvas = document.createElement('canvas');
			outCanvas.width = chipW;
			outCanvas.height = chipH;
			const outCtx = outCanvas.getContext('2d');
			
			outCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, chipW, chipH);
			
			// Convert to WebP with compression
			return outCanvas.toDataURL('image/webp', 0.85);
		}

		// Crop event handlers
		cropZoom.addEventListener('input', () => {
			cropState.zoom = parseFloat(cropZoom.value);
			cropZoomValue.textContent = Math.round(cropState.zoom * 100) + '%';
			renderCrop();
		});

		cropContainer.addEventListener('mousedown', (e) => {
			cropState.dragging = true;
			cropState.startX = e.clientX - cropState.x;
			cropState.startY = e.clientY - cropState.y;
			e.preventDefault();
		});

		cropContainer.addEventListener('mousemove', (e) => {
			if (!cropState.dragging) return;
			cropState.x = e.clientX - cropState.startX;
			cropState.y = e.clientY - cropState.startY;
			renderCrop();
		});

		cropContainer.addEventListener('mouseup', () => {
			cropState.dragging = false;
		});

		cropContainer.addEventListener('mouseleave', () => {
			cropState.dragging = false;
		});

		cropContainer.addEventListener('wheel', (e) => {
			e.preventDefault();
			const delta = e.deltaY > 0 ? -0.1 : 0.1;
			cropState.zoom = Math.max(0.5, Math.min(3, cropState.zoom + delta));
			cropZoom.value = cropState.zoom;
			cropZoomValue.textContent = Math.round(cropState.zoom * 100) + '%';
			renderCrop();
		}, { passive: false });

		cropApply.addEventListener('click', () => {
			const croppedData = getCroppedImage();
			if (croppedData && cropCallback) {
				cropCallback(croppedData, cropTargetKey);
			}
			closeCropModal();
		});

		cropCancel.addEventListener('click', closeCropModal);
		// =============================================
		// End Image Crop
		// =============================================

		// Key Image Modal Elements
		const modalKeyImage = document.getElementById('modalKeyImage');
		const closeKeyImage = document.getElementById('closeKeyImage');
		const kiDefaultImg = document.getElementById('ki_default_img');
		const kiDefaultClear = document.getElementById('ki_default_clear');
		const kiDefaultHide = document.getElementById('ki_default_hide');
		const kiDefaultPreview = document.getElementById('ki_default_preview');
		const kiDefaultPreviewImg = document.getElementById('ki_default_preview_img');
		const kiKeySelect = document.getElementById('ki_key_select');
		const kiAddCustom = document.getElementById('ki_add_custom');
		const kiKeyConfig = document.getElementById('ki_key_config');
		const kiSelectedKey = document.getElementById('ki_selected_key');
		const kiKeyImg = document.getElementById('ki_key_img');
		const kiKeyClear = document.getElementById('ki_key_clear');
		const kiKeyHide = document.getElementById('ki_key_hide');
		const kiKeyPreview = document.getElementById('ki_key_preview');
		const kiKeyPreviewImg = document.getElementById('ki_key_preview_img');
		const kiKeySave = document.getElementById('ki_key_save');
		const kiConfiguredList = document.getElementById('ki_configured_list');
		const kiClearAll = document.getElementById('ki_clear_all');
		const kiPreviewQueue = document.getElementById('ki_preview_queue');

		let currentEditKey = null;
		let pendingKeyImage = null;

		function openModalKeyImage() {
			modalKeyImage.style.display = 'flex';
			loadKeyImageSettings();
			populateKeySelect();
			updateConfiguredList();
			updateKIPreview();
		}
		function closeModalKeyImage() {
			modalKeyImage.style.display = 'none';
			currentEditKey = null;
			pendingKeyImage = null;
		}

		function loadKeyImageSettings() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			// Load default settings
			if (images['default']) {
				kiDefaultPreview.style.display = 'block';
				kiDefaultPreviewImg.src = images['default'];
			} else {
				kiDefaultPreview.style.display = 'none';
			}
			kiDefaultHide.checked = !!hides['default'];
		}

		function populateKeySelect() {
			const selectText = currentLanguage === 'ko' ? '-- í‚¤ ì„ íƒ --' : '-- Select Key --';
			kiKeySelect.innerHTML = `<option value="">${selectText}</option>`;
			COMMON_KEYS.forEach(k => {
				const opt = document.createElement('option');
				opt.value = k;
				opt.textContent = k;
				kiKeySelect.appendChild(opt);
			});
		}

		function updateConfiguredList() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			const keys = new Set([...Object.keys(images), ...Object.keys(hides)]);
			keys.delete('default'); // Don't show default in list
			
			if (keys.size === 0) {
				const emptyText = currentLanguage === 'ko' ? 'ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤' : 'No keys configured';
				kiConfiguredList.innerHTML = `<div class="help" style="text-align:center; padding:20px">${emptyText}</div>`;
				return;
			}
			
			let html = '';
			Array.from(keys).sort().forEach(key => {
				const hasImg = !!images[key];
				const hideText = !!hides[key];
				const imgIcon = hasImg ? 'ğŸ–¼ï¸' : '';
				const hideIcon = hideText ? 'ğŸ‘ï¸â€ğŸ—¨ï¸' : '';
				html += `<div style="display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px solid var(--border)">
					<span class="badge">${key}</span>
					<span style="font-size:12px">${imgIcon} ${hideIcon}</span>
					<span class="spacer"></span>
					<button onclick="editKeyImage('${key}')" style="padding:4px 8px; font-size:11px" data-text-ko="í¸ì§‘" data-text-en="Edit">í¸ì§‘</button>
					<button onclick="removeKeyImage('${key}')" class="danger" style="padding:4px 8px; font-size:11px" data-text-ko="ì‚­ì œ" data-text-en="Delete">ì‚­ì œ</button>
				</div>`;
			});
			kiConfiguredList.innerHTML = html;
		}

		// Expose functions globally for onclick handlers
		window.editKeyImage = function(key) {
			currentEditKey = key;
			kiSelectedKey.textContent = key;
			kiKeyConfig.style.display = 'block';
			
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			if (images[key]) {
				kiKeyPreview.style.display = 'block';
				kiKeyPreviewImg.src = images[key];
				pendingKeyImage = images[key];
			} else {
				kiKeyPreview.style.display = 'none';
				pendingKeyImage = null;
			}
			kiKeyHide.checked = !!hides[key];
			kiKeyImg.value = '';
		};

		window.removeKeyImage = function(key) {
			const images = getKeyImages();
			const hides = getHideKeyText();
			delete images[key];
			delete hides[key];
			setKeyImages(images);
			setHideKeyText(hides);
			updateConfiguredList();
			updateKIPreview();
			
			if (currentEditKey === key) {
				kiKeyConfig.style.display = 'none';
				currentEditKey = null;
			}
		};

		function updateKIPreview() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			// Include longer keys like SPACE, ENTER for preview
			const sampleKeys = ['Q', 'W', 'SPACE', 'ENTER'];
			
			kiPreviewQueue.innerHTML = '';
			sampleKeys.forEach(k => {
				const chip = document.createElement('div');
				chip.className = 'chip';
				chip.style.cssText = 'background:var(--chip-bg, rgba(0,0,0,0.6)); color:var(--chip-fg, #fff); padding:10px 14px; border-radius:10px; font-size:24px; font-weight:700; min-width:44px; text-align:center; display:flex; align-items:center; justify-content:center; background-size:cover; background-position:center;';
				
				const img = images[k] || images['default'];
				const hideText = hides[k] !== undefined ? hides[k] : hides['default'];
				
				// Set image as background
				if (img) {
					chip.style.backgroundImage = `url(${img})`;
				}
				
				// Always add text to maintain size, use transparent color if hidden
				chip.textContent = k;
				if (hideText) {
					chip.style.color = 'transparent';
				}
				
				kiPreviewQueue.appendChild(chip);
			});
		}

		// Event Handlers
		closeKeyImage.addEventListener('click', closeModalKeyImage);

		kiDefaultImg.addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			
			// Check file size (max 5MB for upload, will be compressed after crop)
			if (file.size > 5 * 1024 * 1024) {
				alert(currentLanguage === 'ko' ? 'ì´ë¯¸ì§€ í¬ê¸°ê°€ 5MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤' : 'Image size exceeds 5MB');
				kiDefaultImg.value = '';
				return;
			}
			
			const base64 = await fileToBase64(file);
			// Open crop modal
			openCropModal(base64, 'default', (croppedData, targetKey) => {
				const images = getKeyImages();
				images[targetKey] = croppedData;
				setKeyImages(images);
				
				kiDefaultPreview.style.display = 'block';
				kiDefaultPreviewImg.src = croppedData;
				updateKIPreview();
			});
			kiDefaultImg.value = '';
		});

		kiDefaultClear.addEventListener('click', () => {
			const images = getKeyImages();
			delete images['default'];
			setKeyImages(images);
			kiDefaultPreview.style.display = 'none';
			kiDefaultImg.value = '';
			updateKIPreview();
		});

		kiDefaultHide.addEventListener('change', () => {
			const hides = getHideKeyText();
			hides['default'] = kiDefaultHide.checked;
			setHideKeyText(hides);
			updateKIPreview();
		});

		kiKeySelect.addEventListener('change', () => {
			const key = kiKeySelect.value;
			if (!key) {
				kiKeyConfig.style.display = 'none';
				currentEditKey = null;
				return;
			}
			window.editKeyImage(key);
		});

		kiAddCustom.addEventListener('click', () => {
			const promptText = currentLanguage === 'ko' ? 'í‚¤ ì´ë¦„ ì…ë ¥ (ì˜ˆ: SPACE, LCMD):' : 'Enter key name (e.g., SPACE, LCMD):';
			const key = prompt(promptText);
			if (key && key.trim()) {
				window.editKeyImage(key.trim().toUpperCase());
				kiKeySelect.value = '';
			}
		});

		kiKeyImg.addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			
			// Check file size (max 5MB for upload, will be compressed after crop)
			if (file.size > 5 * 1024 * 1024) {
				alert(currentLanguage === 'ko' ? 'ì´ë¯¸ì§€ í¬ê¸°ê°€ 5MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤' : 'Image size exceeds 5MB');
				kiKeyImg.value = '';
				return;
			}
			
			const base64 = await fileToBase64(file);
			// Open crop modal
			openCropModal(base64, currentEditKey, (croppedData, targetKey) => {
				pendingKeyImage = croppedData;
				kiKeyPreview.style.display = 'block';
				kiKeyPreviewImg.src = croppedData;
			});
			kiKeyImg.value = '';
		});

		kiKeyClear.addEventListener('click', () => {
			pendingKeyImage = null;
			kiKeyPreview.style.display = 'none';
			kiKeyImg.value = '';
		});

		kiKeySave.addEventListener('click', () => {
			if (!currentEditKey) return;
			
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			if (pendingKeyImage) {
				images[currentEditKey] = pendingKeyImage;
			} else {
				delete images[currentEditKey];
			}
			
			if (kiKeyHide.checked) {
				hides[currentEditKey] = true;
			} else {
				delete hides[currentEditKey];
			}
			
			setKeyImages(images);
			setHideKeyText(hides);
			
			updateConfiguredList();
			updateKIPreview();
			
			// Reset form
			kiKeyConfig.style.display = 'none';
			kiKeySelect.value = '';
			currentEditKey = null;
			pendingKeyImage = null;
		});

		kiClearAll.addEventListener('click', () => {
			const confirmText = currentLanguage === 'ko' ? 'ëª¨ë“  í‚¤ ì´ë¯¸ì§€ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?' : 'Clear all key image settings?';
			if (confirm(confirmText)) {
				localStorage.removeItem(STORAGE_KEY_IMAGES);
				localStorage.removeItem(STORAGE_KEY_HIDE);
				loadKeyImageSettings();
				updateConfiguredList();
				updateKIPreview();
				kiKeyConfig.style.display = 'none';
			}
		});
		// =============================================
		// End Key Image Settings
		// =============================================

		function safeAddEventListener(element, event, handler) {
			if (element && typeof element.addEventListener === 'function') {
				element.addEventListener(event, handler);
			}
		}

		const modalAll = document.getElementById('modalAll');
		const cancelAll = document.getElementById('cancelAll');
		const saveAll = document.getElementById('saveAll');
		let confirmTimer = null;

		const modalOverlay = document.getElementById('modalOverlay');
		const openOverlayCfg = document.getElementById('openOverlayCfg');
		const closeOverlay = document.getElementById('closeOverlay');
		const saveOverlay = document.getElementById('saveOverlay');

		const ov_fade_in = document.getElementById('ov_fade_in');
		const ov_fade_out = document.getElementById('ov_fade_out');
		const ov_chip_bg = document.getElementById('ov_chip_bg');
		const ov_chip_fg = document.getElementById('ov_chip_fg');
		const ov_bg_pickBtn = document.getElementById('ov_bg_pick');
		const ov_bg_picker = document.getElementById('ov_bg_picker');
		const ov_bg_trans = document.getElementById('ov_bg_trans');
		const ov_chip_bg_pickBtn = document.getElementById('ov_chip_bg_pick');
		const ov_chip_bg_picker = document.getElementById('ov_chip_bg_picker');
		const ov_chip_fg_pickBtn = document.getElementById('ov_chip_fg_pick');
		const ov_chip_fg_picker = document.getElementById('ov_chip_fg_picker');
		const ov_bg = document.getElementById('ov_bg');
		const ov_gap = document.getElementById('ov_gap');
		const ov_pad_v = document.getElementById('ov_pad_v');
		const ov_pad_h = document.getElementById('ov_pad_h');
		const ov_radius = document.getElementById('ov_radius');
		const ov_font_px = document.getElementById('ov_font_px');
		const ov_font_w = document.getElementById('ov_font_w');
		const ov_cols = document.getElementById('ov_cols');
		const ov_rows = document.getElementById('ov_rows');
		const ov_align = document.getElementById('ov_align');
		const ov_direction = document.getElementById('ov_direction');

		const debugMode = document.getElementById('debugMode');
		const debugValue = document.getElementById('debugValue');
		const debugStatus = document.getElementById('debugStatus');

		let savedValue = '';
		let currentLanguage = 'ko'; // ê¸°ë³¸ê°’ì„ í•œêµ­ì–´ë¡œ ì„¤ì •
		let currentStatus = ''; // í˜„ì¬ ì‘ë™ ìƒíƒœ ì €ì¥

		async function loadLanguageSettings() {
			try {
				const response = await fetch('/api/launcher-language');
				if (response.ok) {
					const data = await response.json();
					currentLanguage = data.language || 'ko';
					console.log('âœ“ Language loaded:', currentLanguage);
					updateUILanguage();
				} else {
					console.warn('Failed to load language, using default: ko');
					currentLanguage = 'ko';
					updateUILanguage();
				}
			} catch (e) {
				console.error('Error loading language:', e);
				currentLanguage = 'ko'; // ì—ëŸ¬ ì‹œì—ë„ í•œêµ­ì–´ë¥¼ ê¸°ë³¸ìœ¼ë¡œ
				updateUILanguage();
			}
		}

		function updateUILanguage() {
			const lang = currentLanguage;
			
			document.querySelectorAll('[data-text-ko], [data-text-en]').forEach(element => {
				const koText = element.getAttribute('data-text-ko');
				const enText = element.getAttribute('data-text-en');
				
				if (lang === 'ko' && koText) {
					element.textContent = koText;
				} else if (lang === 'en' && enText) {
					element.textContent = enText;
				}
			});

			document.querySelectorAll('[data-title-ko], [data-title-en]').forEach(element => {
				const koTitle = element.getAttribute('data-title-ko');
				const enTitle = element.getAttribute('data-title-en');
				
				if (lang === 'ko' && koTitle) {
					element.title = koTitle;
				} else if (lang === 'en' && enTitle) {
					element.title = enTitle;
				}
			});

			document.querySelectorAll('select option[data-text-ko], select option[data-text-en]').forEach(option => {
				const koText = option.getAttribute('data-text-ko');
				const enText = option.getAttribute('data-text-en');
				
				if (lang === 'ko' && koText) {
					option.textContent = koText;
				} else if (lang === 'en' && enText) {
					option.textContent = enText;
				}
			});

			if (lang === 'ko') {
				document.title = 'Key Queue Viewer ì„¤ì •';
			} else {
				document.title = 'Key Queue Viewer Settings';
			}

			if (statusEl.textContent) {
				if (statusEl.textContent === 'ì €ì¥ ì¤‘...' || statusEl.textContent === 'Saving...') {
					statusEl.textContent = lang === 'ko' ? 'ì €ì¥ ì¤‘...' : 'Saving...';
				} else if (statusEl.textContent === 'ì ìš©ë¨' || statusEl.textContent === 'Applied') {
					statusEl.textContent = lang === 'ko' ? 'ì ìš©ë¨' : 'Applied';
				} else if (statusEl.textContent === 'ì˜¤ë¥˜' || statusEl.textContent === 'Error') {
					statusEl.textContent = lang === 'ko' ? 'ì˜¤ë¥˜' : 'Error';
				}
			}

			if (fginfoEl.textContent && fginfoEl.textContent.includes('ì½ê¸° ì‹¤íŒ¨')) {
				fginfoEl.textContent = lang === 'ko' ? 'ì½ê¸° ì‹¤íŒ¨' : 'Read Failed';
			}
			if (currentStatus) {
				if (currentStatus === 'ë¹„í™œì„±í™”' || currentStatus === 'Disabled') {
					currentStatus = lang === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (currentStatus === 'ëª¨ë“  ì°½ í™œì„±í™”' || currentStatus === 'All Windows Active') {
					currentStatus = lang === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (currentStatus === 'í™œì„±í™”' || currentStatus === 'Active') {
					currentStatus = lang === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else if (currentStatus === 'ì„¤ì • ì•ˆë¨' || currentStatus === 'Not Configured') {
					currentStatus = lang === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
			}
			
			updateDebugInfo();
		}

		function updateDebugInfo() {
			debugMode.textContent = modeEl.value || '-';
			debugValue.textContent = savedValue || '-';
			debugStatus.textContent = currentStatus || '-';
		}

		function openModalAll(){
			modalAll.style.display = 'flex';
			saveAll.disabled = true;
			if (confirmTimer) clearTimeout(confirmTimer);
			confirmTimer = setTimeout(()=> { saveAll.disabled = false; }, 2000);
		}
		function closeModalAll(){
			modalAll.style.display = 'none';
			if (confirmTimer) clearTimeout(confirmTimer);
		}

		function openModalOverlay(){ modalOverlay.style.display = 'flex'; }
		function closeModalOverlay(){ modalOverlay.style.display = 'none'; }

		function isValidHex(h){ return /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(h); }
		function setPickBtn(btn, val){ if (isValidHex(val)) { btn.style.background = val; } }
        function hookColorPair(textEl, pickBtn, picker){
            pickBtn.addEventListener('click', (ev)=> {
                // Try native picker first
                try { if (picker.showPicker) { picker.showPicker(); return; } } catch(_){ }

                // Show custom palette popover near the button
                const rect = pickBtn.getBoundingClientRect();
                const pop = document.createElement('div');
                pop.className = 'color-popover';
                pop.style.left = Math.round(rect.left) + 'px';
                pop.style.top = Math.round(rect.bottom + 6) + 'px';

                // Preset swatches (Material-ish)
                const presets = ['#000000','#111111','#222222','#444444','#666666','#888888','#bbbbbb','#ffffff',
                                 '#ff0000','#ff6b6b','#ffa94d','#ffd43b','#94d82d','#38d9a9','#4dabf7','#845ef7'];
                const sw = document.createElement('div'); sw.className = 'swatches';
                presets.forEach(c => { const d = document.createElement('div'); d.className = 'swatch'; d.style.background = c; d.title = c; d.addEventListener('click', ()=> { textEl.value = c; setPickBtn(pickBtn, c); updatePreview(); remove(); }); sw.appendChild(d); });

                // Hex + native input row
                const row = document.createElement('div'); row.className = 'row';
                const hex = document.createElement('input'); hex.type = 'text'; hex.placeholder = '#rrggbb'; hex.value = textEl.value || '#000000';
                const native = document.createElement('input'); native.type = 'color'; native.value = (textEl.value && /^#([0-9a-fA-F]{6})$/.test(textEl.value)) ? textEl.value : '#000000';
                hex.addEventListener('input', ()=> { if (/^#([0-9a-fA-F]{6})$/.test(hex.value)) { native.value = hex.value; } });
                native.addEventListener('input', ()=> { hex.value = native.value; });

                // Actions
                const actions = document.createElement('div'); actions.className = 'actions';
                const btnOk = document.createElement('button'); btnOk.className = 'btn'; btnOk.textContent = 'OK';
                const btnCancel = document.createElement('button'); btnCancel.className = 'btn'; btnCancel.textContent = 'Cancel';
                btnOk.addEventListener('click', ()=> { if (/^#([0-9a-fA-F]{6})$/.test(hex.value)) { textEl.value = hex.value; setPickBtn(pickBtn, hex.value); updatePreview(); } remove(); });
                btnCancel.addEventListener('click', remove);

                actions.appendChild(btnCancel); actions.appendChild(btnOk);
                row.appendChild(hex); row.appendChild(native);
                pop.appendChild(sw); pop.appendChild(row); pop.appendChild(actions);
                document.body.appendChild(pop);

                // Close when clicking outside
                function onDoc(e){ if (!pop.contains(e.target) && e.target !== pickBtn) remove(); }
                function remove(){ document.removeEventListener('mousedown', onDoc, true); try { document.body.removeChild(pop); } catch(_){} }
                setTimeout(()=> document.addEventListener('mousedown', onDoc, true), 0);
            });
            picker.addEventListener('input', ()=> { textEl.value = picker.value; setPickBtn(pickBtn, textEl.value); updatePreview(); });
            textEl.addEventListener('input', ()=> { setPickBtn(pickBtn, textEl.value); updatePreview(); });
        }

		function updatePreview(){
			const root = ov_preview;
			root.style.setProperty('--chip-bg', ov_chip_bg.value || 'rgba(0,0,0,0.6)');
			root.style.setProperty('--chip-fg', ov_chip_fg.value || '#ffffff');
			const bgVal = ov_bg_trans.checked ? 'rgba(0,0,0,0)' : (ov_bg.value || 'rgba(0,0,0,0)');
			root.style.setProperty('--bg', bgVal);
			root.style.setProperty('--chip-gap', (Number(ov_gap.value)||8) + 'px');
			root.style.setProperty('--chip-pad-v', (Number(ov_pad_v.value)||10) + 'px');
			root.style.setProperty('--chip-pad-h', (Number(ov_pad_h.value)||14) + 'px');
			root.style.setProperty('--chip-radius', (Number(ov_radius.value)||10) + 'px');
			root.style.setProperty('--chip-font', (Number(ov_font_px.value)||24) + 'px');
			root.style.setProperty('--chip-font-weight', String(Number(ov_font_w.value)||700));
			root.style.setProperty('--fade-in', (Number(ov_fade_in.value)||120) + 'ms');
			root.style.setProperty('--fade-out', (Number(ov_fade_out.value)||120) + 'ms');
			const colsVal = Number(ov_cols.value)||8;
			const rowsVal = Number(ov_rows.value)||1;
			root.style.setProperty('--cols', String(colsVal));
			root.style.setProperty('--rows', String(rowsVal));
			root.style.setProperty('--single-scale', '1');
			const alignMap = { left: 'left', center: 'center', right: 'right' };
			root.style.setProperty('--align', alignMap[ov_align.value] || 'left');
			root.style.setProperty('--dir', (ov_direction.value === 'rtl') ? 'rtl' : 'ltr');

			// Rebuild preview chips: Q,W,E,R but obey capacity when rows>0
			const labels = ['Q','W','E','R'];
			const cols = colsVal; const rows = rowsVal;
			let count = labels.length;
			if (rows > 0) { const cap = Math.max(1, cols * rows); count = Math.min(count, cap); }
			ov_preview_queue.style.gridTemplateColumns = `repeat(${cols}, max-content)`;
			ov_preview_queue.style.justifyContent = alignMap[ov_align.value] || 'left';
			ov_preview_queue.style.direction = (ov_direction.value === 'rtl') ? 'rtl' : 'ltr';
			ov_preview_queue.innerHTML = '';
			
			// Get key image settings for preview
			const keyImages = getKeyImages();
			const hideKeyText = getHideKeyText();
			
			for (let i=0;i<count;i++){
				const k = labels[i];
				const chip = document.createElement('div');
				chip.className = 'chip';
				chip.style.backgroundSize = 'cover';
				chip.style.backgroundPosition = 'center';
				
				// Apply key image if exists
				const img = keyImages[k] || keyImages['default'];
				if (img) {
					chip.style.backgroundImage = `url(${img})`;
				}
				
				// Apply text (transparent if hidden)
				chip.textContent = k;
				const hideText = hideKeyText[k] !== undefined ? hideKeyText[k] : hideKeyText['default'];
				if (hideText) {
					chip.style.color = 'transparent';
				}
				
				ov_preview_queue.appendChild(chip);
			}
		}

		['input','change'].forEach(evt=>{
			[ov_fade_in,ov_fade_out,ov_chip_bg,ov_chip_fg,ov_bg,ov_gap,ov_pad_v,ov_pad_h,ov_radius,ov_font_px,ov_font_w,ov_cols,ov_rows,ov_align,ov_direction].forEach(el=>{
				el.addEventListener(evt, updatePreview);
			});
		});

		async function loadOverlayConfig(){
			try{
				const res = await fetch('/api/overlay-config');
				const c = await res.json();
				ov_fade_in.value = c.fade_in_ms ?? 120;
				ov_fade_out.value = c.fade_out_ms ?? 120;
				// Check if background is transparent (rgba(0,0,0,0), transparent, or #00000000)
				const isTrans = (typeof c.background === 'string') && (
					c.background.toLowerCase() === 'transparent' || 
					c.background === 'rgba(0,0,0,0)' ||
					c.background === 'rgba(0, 0, 0, 0)' ||
					c.background === '#00000000'
				);
				ov_bg_trans.checked = !!isTrans;
				ov_bg.disabled = !!isTrans; ov_bg_pickBtn.disabled = !!isTrans;
				ov_bg.value = (!isTrans && c.background && c.background.startsWith('#')) ? c.background : '#000000';
				ov_chip_bg.value = (c.chip_bg && c.chip_bg.startsWith('#')) ? c.chip_bg : '#000000';
				ov_chip_fg.value = (c.chip_fg && c.chip_fg.startsWith('#')) ? c.chip_fg : '#ffffff';
				ov_gap.value = c.chip_gap ?? 8;
				ov_pad_v.value = c.chip_pad_v ?? 10;
				ov_pad_h.value = c.chip_pad_h ?? 14;
				ov_radius.value = c.chip_radius ?? 10;
				ov_font_px.value = c.chip_font_px ?? 24;
				ov_font_w.value = c.chip_font_weight ?? 700;
				ov_cols.value = c.cols ?? 8;
				ov_rows.value = c.rows ?? 1;
				ov_align.value = (c.align || 'left'); // Default to left
				ov_direction.value = (c.direction || 'ltr');
				setPickBtn(ov_bg_pickBtn, ov_bg.value);
				setPickBtn(ov_chip_bg_pickBtn, ov_chip_bg.value);
				setPickBtn(ov_chip_fg_pickBtn, ov_chip_fg.value);
				updatePreview();
			}catch(e){}
		}

		async function saveOverlayConfig(){
			const payload = {
				fade_in_ms: Number(ov_fade_in.value),
				fade_out_ms: Number(ov_fade_out.value),
				background: (ov_bg_trans.checked ? 'rgba(0,0,0,0)' : ov_bg.value),
				chip_bg: ov_chip_bg.value,
				chip_fg: ov_chip_fg.value,
				chip_gap: Number(ov_gap.value),
				chip_pad_v: Number(ov_pad_v.value),
				chip_pad_h: Number(ov_pad_h.value),
				chip_radius: Number(ov_radius.value),
				chip_font_px: Number(ov_font_px.value),
				chip_font_weight: Number(ov_font_w.value),
				cols: Number(ov_cols.value),
				rows: Number(ov_rows.value),
				align: ov_align.value,
				direction: ov_direction.value
			};
			try{
				await fetch('/api/overlay-config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
				closeModalOverlay();
			}catch(e){}
		}

		async function refreshTarget(){
			try {
				const res = await fetch('/api/target');
				const j = await res.json();
				modeEl.value = j.mode || 'process'; // ê¸°ë³¸ê°’: í”„ë¡œì„¸ìŠ¤
				valuePick.value = j.value || '';
				savedValue = j.value || '';
				
				if (j.mode === 'disabled') {
					currentStatus = currentLanguage === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (j.mode === 'all') {
					currentStatus = currentLanguage === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (j.value) {
					currentStatus = currentLanguage === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else {
					currentStatus = currentLanguage === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
				
				refreshPickerForMode();
				updateDebugInfo();
			} catch (e) {
				// If server is not available, try to restore from localStorage (Portable mode)
				try {
					const lastMode = localStorage.getItem('last_mode');
					const lastValue = localStorage.getItem('last_value');
					if (lastMode) {
						modeEl.value = lastMode;
						savedValue = lastValue || '';
						
						// Auto-apply if we have saved settings
						if (lastMode !== 'disabled' && lastValue) {
							await doApply(lastMode, lastValue);
						}
					}
				} catch(localErr) {
					// If localStorage fails, use defaults
					modeEl.value = 'disabled';
					savedValue = '';
				}
				
				refreshPickerForMode();
				updateDebugInfo();
			}
		}

		async function apply(){
			const m = modeEl.value;
			if (m === 'all') { openModalAll(); return; }
			await doApply(m, valuePick.value || null);
		}

		async function doApply(mode, value){
			statusEl.textContent = currentLanguage === 'ko' ? 'ì €ì¥ ì¤‘...' : 'Saving...';
			updateDebugInfo();
			try{
				await fetch('/api/target', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode, value }) });
				statusEl.textContent = currentLanguage === 'ko' ? 'ì ìš©ë¨' : 'Applied';
				savedValue = value || '';
				
				// Save to localStorage for portable
				try {
					localStorage.setItem('last_mode', mode);
					localStorage.setItem('last_value', value || '');
				} catch(e) {}
				
				// ì ìš© í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
				if (mode === 'disabled') {
					currentStatus = currentLanguage === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (mode === 'all') {
					currentStatus = currentLanguage === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (value) {
					currentStatus = currentLanguage === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else {
					currentStatus = currentLanguage === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
				
				updateDebugInfo();
			}catch(e){ 
				statusEl.textContent = currentLanguage === 'ko' ? 'ì˜¤ë¥˜' : 'Error'; 
				updateDebugInfo();
			}
		}

		function setSort(newKey){
			if (sortKey === newKey){ sortDir = (sortDir === 'asc') ? 'desc' : 'asc'; }
			else { sortKey = newKey; sortDir = 'asc'; }
			updateHeaderArrows();
			// Re-render
			fillTable();
			refreshPickerForMode();
		}

		function updateHeaderArrows(){
			Object.keys(arrowMap).forEach(k => { 
				if (arrowMap[k] && typeof arrowMap[k].textContent !== 'undefined') {
					arrowMap[k].textContent = ''; 
				}
			});
			const arr = arrowMap[sortKey];
			if (arr && typeof arr.textContent !== 'undefined') {
				arr.textContent = (sortDir === 'asc') ? 'â–²' : 'â–¼';
			}
		}

		function sortWindows(list){
			const dir = (sortDir === 'asc') ? 1 : -1;
			const copy = Array.from(list || []);
			copy.sort((a,b)=>{
				let av = a?.[sortKey] ?? '';
				let bv = b?.[sortKey] ?? '';
				if (sortKey === 'hwnd'){
					const an = Number(av)||0, bn = Number(bv)||0;
					if (an === bn) return 0;
					return an < bn ? -dir : dir;
				}
				av = String(av);
				bv = String(bv);
				const cmp = av.localeCompare(bv);
				return cmp * dir;
			});
			return copy;
		}

		function fillTable(){
			const sorted = sortWindows(lastWindows);
			if (winTableBody){
				winTableBody.innerHTML = sorted.map(w => `
					<tr data-title="${w.title||''}" data-process="${w.process||''}" data-hwnd="${w.hwnd||''}" data-class="${w.class||''}" class="window-row">
						<td title="${w.title||''}">${w.title||''}</td>
						<td title="${w.process||''}">${w.process||''}</td>
						<td title="${w.hwnd||''}">${w.hwnd||''}</td>
						<td title="${w.class||''}">${w.class||''}</td>
					</tr>
				`).join('');
				
				// Attach row click handlers for auto-target selection
				winTableBody.querySelectorAll('tr.window-row').forEach(tr => {
					tr.style.cursor = 'pointer';
					tr.addEventListener('click', async () => {
						let currentMode = modeEl.value;
						
						// If mode is disabled, automatically change to process mode
						if (currentMode === 'disabled') {
							modeEl.value = 'process';
							currentMode = 'process';
							refreshPickerForMode(); // Update picker options for process mode
						}
						
						// If no mode selected, default to process
						if (!currentMode || currentMode === '') {
							modeEl.value = 'process';
							currentMode = 'process';
						}
						
						// Skip for "all" mode
						if (currentMode === 'all') {
							return; // Do nothing for all mode
						}
						
						// Get value based on current mode
						let targetValue = '';
						if (currentMode === 'title') targetValue = tr.getAttribute('data-title');
						else if (currentMode === 'process') targetValue = tr.getAttribute('data-process');
						else if (currentMode === 'hwnd') targetValue = tr.getAttribute('data-hwnd');
						else if (currentMode === 'class') targetValue = tr.getAttribute('data-class');
						
						if (!targetValue) return;
						
						// Auto-apply the selected value
						valuePick.value = targetValue;
						await doApply(currentMode, targetValue);
						
						// Save to localStorage for portable
						try {
							localStorage.setItem('last_mode', currentMode);
							localStorage.setItem('last_value', targetValue);
						} catch(e) {}
					});
				});
			}
		}

		async function loadWindows(){
			try{
				const res = await fetch('/api/windows');
				const list = await res.json();
				lastWindows = Array.isArray(list) ? list : [];
				fillTable();
				
				if (!valuePick.matches(':focus') && document.activeElement !== valuePick) {
					refreshPickerForMode();
				}
			}catch(e){
				lastWindows = [];
				if (winTableBody){ winTableBody.innerHTML = ''; }
				
				if (!valuePick.matches(':focus') && document.activeElement !== valuePick) {
					refreshPickerForMode();
				}
			}
		}

		function refreshPickerForMode(){
			const m = modeEl.value;
			
			let values = [];
			if (m === 'title') values = lastWindows.map(w => w.title).filter(Boolean);
			if (m === 'process') values = lastWindows.map(w => w.process).filter(Boolean);
			if (m === 'class') values = lastWindows.map(w => w.class).filter(Boolean);
			if (m === 'hwnd') values = lastWindows.map(w => w.hwnd).filter(Boolean);
			const uniq = Array.from(new Set(values));
			if (m === 'hwnd') uniq.sort((a,b)=> ((Number(a)||0) - (Number(b)||0)) * (sortDir==='asc'?1:-1));
			else uniq.sort((a,b)=> String(a||'').localeCompare(String(b||'')) * (sortDir==='asc'?1:-1));
			
			const selectText = currentLanguage === 'ko' ? 'ì„ íƒ...' : 'Select...';
			valuePick.innerHTML = `<option value="">${selectText}</option>` + uniq.map(v => `<option value="${String(v)}">${String(v)}</option>`).join('');
			
			// í•­ìƒ ì €ì¥ëœ ê°’ë§Œ í‘œì‹œ (ì‚¬ìš©ìê°€ ì„ íƒí•œ ê°’ ë¬´ì‹œ)
			if (savedValue && uniq.includes(savedValue)) {
				valuePick.value = savedValue;
			} else {
				valuePick.value = '';
			}
			
			updateDebugInfo();
		}

		async function loadConfig(){
			// Port configuration is now handled in the launcher
			// This function is kept for future use if needed
		}

		async function loadForeground(){
			try{
				const res = await fetch('/api/foreground');
				const j = await res.json();
				fginfoEl.textContent = `HWND=${j.hwnd||''} | TITLE=${j.title||''} | PROCESS=${j.process_name||''} | CLASS=${j.class||''}`;
			}catch(e){
				fginfoEl.textContent = currentLanguage === 'ko' ? 'ì½ê¸° ì‹¤íŒ¨' : 'Read Failed';
			}
		}

		document.getElementById('apply').addEventListener('click', apply);
		// document.getElementById('savePort').addEventListener('click', savePort); // Removed savePort
		// valuePick.addEventListener('change', ()=>{ updateDebugInfo(); }); // ì‚¬ìš©ìê°€ ì„ íƒí•œ ê°’ì€ ì €ì¥ ì „ê¹Œì§€ ë¬´ì‹œ
		modeEl.addEventListener('change', ()=> { 
			refreshPickerForMode(); 
			updateDebugInfo();
		});
		openOverlayCfg.addEventListener('click', async ()=>{ await loadOverlayConfig(); openModalOverlay(); });
		closeOverlay.addEventListener('click', ()=> closeModalOverlay());
		saveOverlay.addEventListener('click', saveOverlayConfig);
		
		// Open key image settings from overlay settings modal
		document.getElementById('ov_open_key_image').addEventListener('click', () => {
			closeModalOverlay();
			openModalKeyImage();
		});

		cancelAll.addEventListener('click', ()=>{ closeModalAll(); });
		saveAll.addEventListener('click', async ()=>{
			await doApply('all', null);
			closeModalAll();
		});

		hookColorPair(ov_bg, ov_bg_pickBtn, ov_bg_picker);
		hookColorPair(ov_chip_bg, ov_chip_bg_pickBtn, ov_chip_bg_picker);
		hookColorPair(ov_chip_fg, ov_chip_fg_pickBtn, ov_chip_fg_picker);
		ov_bg_trans.addEventListener('change', ()=> { ov_bg.disabled = ov_bg_trans.checked; ov_bg_pickBtn.disabled = ov_bg_trans.checked; updatePreview(); });

		// ì–¸ì–´ ì„¤ì • ë¨¼ì € ë¡œë“œ (ë‹¤ë¥¸ ê²ƒë³´ë‹¤ ìš°ì„ )
		await loadLanguageSettings();
		console.log('âœ“ Language loaded:', currentLanguage);
		
		await Promise.all([refreshTarget(), loadWindows(), loadConfig(), loadForeground()]);
		updateHeaderArrows();
		Object.values(headerMap).forEach(th => {
			if (!th) return;
			safeAddEventListener(th, 'click', ()=> setSort(th.dataset.key));
		});
		updateDebugInfo();
		setInterval(loadWindows, 3000);
		setInterval(loadForeground, 1000);
		setInterval(loadLanguageSettings, 5000); // ì£¼ê¸°ì ìœ¼ë¡œ ì–¸ì–´ ì„¤ì • ê°±ì‹ 
	})();
	</script>
</body>
</html>