<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Key Viewer Control</title>
	<link rel="icon" href="/static/favicon.ico" type="image/x-icon" />
	<link rel="stylesheet" href="/static/control.css">
	<link rel="stylesheet" href="/static/chip.css">
	<style>
		:root{
			--bg:#0b0c10; --panel:#12141a; --panel2:#181b22; --text:#eaeef5; --muted:#9aa4b2; --primary:#4f8cff; --border:#232734;
		}
		html,body{margin:0; font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial; background:var(--bg); color:var(--text)}
		.container{max-width:1000px; margin:24px auto; padding:0 16px}
		.h1{font-size:22px; font-weight:700; margin-bottom:12px}
		.panel{background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:16px; margin-bottom:16px}
		.row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
		label{color:var(--muted)}
		input, select, button{background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px 10px}
		button{cursor:pointer}
		button.primary{background:var(--primary); border-color:var(--primary)}
		table{width:100%; border-collapse:collapse; table-layout:fixed}
		th,td{border-bottom:1px solid var(--border); padding:8px 6px; text-align:left; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
		th.sortable{cursor:pointer; user-select:none}
		th .arrow{font-size:11px; color:var(--muted); margin-left:4px}
		.help{color:var(--muted); line-height:1.6}
		.badge{display:inline-block; background:#2a3040; color:#9ec1ff; border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px}
		.right{margin-left:auto}
		/* Modal */
		.modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,0.65); display:none; align-items:center; justify-content:center; z-index:999}
		.modal{width:560px; max-width:calc(100% - 32px); max-height:calc(100vh - 80px); background:#141821; border:1px solid #2a2f3a; border-radius:12px; padding:0; overflow:hidden; display:flex; flex-direction:column}
		.modal-header{padding:18px 18px 12px; border-bottom:1px solid #2a2f3a}
		.modal-header h3{margin:0; font-size:22px}
		.modal-content{flex:1; overflow-y:auto; padding:18px; scrollbar-width:none; -ms-overflow-style:none}
		.modal-content::-webkit-scrollbar{display:none}
		.modal-footer{padding:14px 18px; border-top:1px solid #2a2f3a}
		.modal .actions{display:flex; gap:10px; justify-content:space-between; margin:0}
		.modal .actions .spacer{flex:1}
		.modal .form-row{display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap}
		.modal .form-row > label{width:140px}
		.modal .form-row > .field{flex:1; min-width:160px}
		.danger{background:#ff5b5b; border-color:#ff5b5b}
		.modal button:disabled{opacity:0.5; filter:grayscale(30%); cursor:not-allowed}

		/* Color picker field */
		.color-field{display:flex; gap:8px; align-items:center}
		.color-field input[type="text"]{flex:1}
		button.pick{width:36px; height:36px; border:1px solid var(--border); border-radius:6px}
		input.picker-hidden{position:absolute; left:-9999px; width:0; height:0; opacity:0}

		/* Custom color palette popover */
		.color-popover{position:fixed; z-index:999999; background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:10px; box-shadow:0 6px 24px rgba(0,0,0,0.35); width:220px}
		.color-popover .swatches{display:grid; grid-template-columns:repeat(8, 1fr); gap:6px; margin-bottom:8px}
		.color-popover .swatch{width:22px; height:22px; border-radius:4px; border:1px solid rgba(255,255,255,0.18); cursor:pointer}
		.color-popover .row{display:flex; align-items:center; gap:6px; margin-bottom:8px}
		.color-popover input[type="text"]{flex:1; background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px; font-size:12px}
		.color-popover input[type="color"]{width:36px; height:28px; border:1px solid var(--border); border-radius:4px; background:transparent}
		.color-popover .actions{display:flex; gap:6px; justify-content:flex-end}
		.color-popover .btn{border:1px solid var(--border); background:var(--panel2); color:var(--text); border-radius:6px; padding:6px 10px; font-size:12px; cursor:pointer}

		/* Key Image Settings styles */
		.key-img-tabs{display:flex; gap:0; border-bottom:1px solid var(--border); margin-bottom:14px}
		.key-img-tabs button{background:transparent; border:none; color:var(--muted); padding:10px 18px; cursor:pointer; border-bottom:2px solid transparent; transition:all 0.15s}
		.key-img-tabs button.active{color:var(--primary); border-bottom-color:var(--primary)}
		.key-img-tabs button:hover{color:var(--text)}
		.key-img-drop{border:2px dashed var(--border); border-radius:10px; padding:32px; text-align:center; cursor:pointer; transition:all 0.2s; background:var(--panel2)}
		.key-img-drop:hover,.key-img-drop.dragover{border-color:var(--primary); background:rgba(79,140,255,0.08)}
		.key-img-drop img{max-width:160px; max-height:120px; border-radius:6px; margin-bottom:10px}
		.key-img-preview{display:flex; align-items:center; gap:12px; padding:12px; background:var(--panel2); border-radius:8px; margin-top:10px}
		.key-img-preview img{width:64px; height:64px; object-fit:contain; border-radius:6px; border:1px solid var(--border)}
		.key-img-list{max-height:260px; overflow-y:auto; scrollbar-width:thin}
		.key-img-item{display:flex; align-items:center; gap:10px; padding:10px; border-radius:8px; background:var(--panel2); margin-bottom:8px}
		.key-img-item img{width:48px; height:48px; object-fit:contain; border-radius:4px; border:1px solid var(--border)}
		.key-img-item .keys{flex:1; font-size:13px}
		.key-img-item .keys span{background:#2a3040; color:#9ec1ff; border-radius:4px; padding:2px 6px; margin-right:4px; font-size:11px}
		.key-img-item button{padding:4px 8px; font-size:11px}
		.key-img-actions{display:flex; gap:4px}
		.group-keys-input{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px}
		.group-keys-input input{flex:1; min-width:200px}
		.gist-section{margin-top:14px; padding-top:14px; border-top:1px solid var(--border)}
		.gist-section input{width:100%; margin-bottom:8px}
		.modal-wide{width:680px}

		/* GitHub Login styles */
		.github-login-section{background:var(--panel2); border-radius:10px; padding:16px; margin-bottom:14px}
		.github-user{display:flex; align-items:center; gap:12px; padding:12px; background:rgba(46,160,67,0.15); border:1px solid rgba(46,160,67,0.3); border-radius:8px}
		.github-user img{width:40px; height:40px; border-radius:50%}
		.github-user .name{font-weight:600; color:#3fb950}
		.github-user .login{font-size:12px; color:var(--muted)}
		.btn-github{display:inline-flex; align-items:center; gap:8px; background:#238636; border-color:#238636; color:#fff; padding:10px 16px; font-weight:500}
		.btn-github:hover{background:#2ea043}
		.btn-github svg{width:18px; height:18px}
		.btn-logout{background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 12px; font-size:12px}
		.or-divider{display:flex; align-items:center; gap:12px; margin:14px 0; color:var(--muted); font-size:12px}
		.or-divider::before,.or-divider::after{content:''; flex:1; height:1px; background:var(--border)}

		/* Key Recording styles */
		.btn-recording{background:#ff4757!important; border-color:#ff4757!important; animation:pulse 1s infinite}
		@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.7}}
		.recorded-key{display:inline-block; background:#2a3040; color:#9ec1ff; border-radius:4px; padding:4px 8px; font-size:12px; font-weight:500}
		.mouse-btn.selected{background:var(--primary)!important; border-color:var(--primary)!important; color:#fff!important}

		/* Image Editor Modal */
		.img-editor-modal{width:700px}
		.img-editor-canvas-wrap{position:relative; background:#000; border-radius:8px; overflow:hidden; margin-bottom:12px}
		.img-editor-canvas{display:block; max-width:100%; margin:0 auto}
		.img-editor-controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:12px}
		.img-editor-controls label{color:var(--muted); font-size:12px}
		.img-editor-controls input[type="range"]{width:120px}
		.img-editor-preview{display:flex; gap:16px; justify-content:center; padding:16px; background:transparent; border-radius:8px; border:1px dashed #2a2f3a}
		.key-shape-preview{display:flex; flex-direction:column; align-items:center; gap:6px}
		.key-shape-preview .label{font-size:11px; color:var(--muted)}
		.key-shape{position:relative; border-radius:6px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.3)}
		.key-shape .bg{position:absolute; inset:0; background-size:cover; background-position:center}
		.key-shape .overlay{position:absolute; inset:0; box-shadow:inset 0 0 0 3px rgba(255,255,255,0.15), inset 0 -2px 4px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.1)}
		.key-shape .text{position:relative; z-index:1; display:flex; align-items:center; justify-content:center; height:100%; font-weight:700; text-shadow:0 1px 2px rgba(0,0,0,0.5)}
		.key-shape.normal{width:52px; height:52px}
		.key-shape.normal .text{font-size:18px}
		.key-shape.wide{width:78px; height:52px}
		.key-shape.wide .text{font-size:14px}
		.key-shape.extra-wide{width:120px; height:52px}
		.key-shape.extra-wide .text{font-size:13px}
		
		/* Editor preview chips - uses shared chip.css, add local overrides here if needed */

		/* Gist List styles */
		.gist-item{display:flex; align-items:center; gap:10px; padding:10px; border-radius:8px; background:var(--panel); margin-bottom:6px; cursor:pointer; border:1px solid transparent; transition:all 0.15s}
		.gist-item:hover{background:var(--panel2); border-color:var(--border)}
		.gist-item.selected{border-color:var(--primary); background:rgba(79,140,255,0.1)}
		.gist-item .gist-name{font-size:13px; font-weight:500; margin-bottom:2px}
		.gist-item .gist-date{font-size:11px; color:var(--muted)}

		/* Overlay preview inside modal */
		.overlay-preview{margin-top:12px; border:1px dashed #2a2f3a; border-radius:10px; padding:12px; background:#0f131b}
		.overlay-preview .queue{display:grid; grid-auto-rows:max-content; gap:var(--chip-gap, 8px)}
		.overlay-preview .chip{
			background: var(--chip-bg, rgba(0,0,0,0.6));
			color: var(--chip-fg, #fff);
			padding: var(--chip-pad-v, 10px) var(--chip-pad-h, 14px);
			border-radius: var(--chip-radius, 10px);
			font-size: var(--chip-font, 24px);
			font-weight: var(--chip-font-weight, 700);
			min-width:44px; text-align:center; user-select:none;
			transition: transform var(--fade-in, 120ms) ease, opacity var(--fade-in, 120ms) ease;
		}
		.overlay-preview .chip.hide{opacity:0; transform: translateY(8px); transition: transform var(--fade-out, 120ms) ease, opacity var(--fade-out, 120ms) ease}

		/* Image Crop Modal */
		.crop-container{position:relative; width:100%; max-height:400px; overflow:hidden; background:#000; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:move}
		.crop-canvas{max-width:100%; max-height:400px}
		.crop-overlay{position:absolute; top:0; left:0; pointer-events:none}
		.crop-info{margin-top:10px; font-size:12px; color:var(--muted)}
		.crop-controls{display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap}
		.crop-controls label{font-size:12px}
		.crop-controls input[type="range"]{flex:1; min-width:100px}
	</style>
	<!-- Utility Modules -->
	<script src="/js/utils.js"></script>
	<script src="/js/gradient-editor.js"></script>
	<script src="/js/chip-preview.js"></script>
</head>
<body>
	<div class="container">
		<div style="display:flex; align-items:center; gap:12px; margin-bottom:12px; flex-wrap:wrap">
			<div class="h1" id="title" style="margin-bottom:0" data-text-ko="Key Queue Viewer ì„¤ì •" data-text-en="Key Queue Viewer Settings">Key Queue Viewer ì„¤ì •</div>
			<div style="flex:1"></div>
			
			<!-- GitHub Login (Logged Out) -->
			<div id="headerLoggedOut">
				<button id="headerLoginBtn" class="btn-github" style="padding:6px 12px; font-size:13px">
					<svg viewBox="0 0 16 16" fill="currentColor" style="width:16px;height:16px"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
					<span data-text-ko="ë¡œê·¸ì¸" data-text-en="Login">ë¡œê·¸ì¸</span>
				</button>
			</div>
			
			<!-- GitHub Login (Logged In) -->
			<div id="headerLoggedIn" style="display:none; align-items:center; gap:8px">
				<img id="headerAvatar" src="" alt="avatar" style="width:28px; height:28px; border-radius:50%; border:2px solid #3fb950"/>
				<span id="headerUsername" style="font-size:13px; color:#3fb950; font-weight:500"></span>
				<button id="headerLogoutBtn" style="padding:4px 8px; font-size:11px; background:transparent; border:1px solid var(--border); color:var(--muted)" data-text-ko="ë¡œê·¸ì•„ì›ƒ" data-text-en="Logout">ë¡œê·¸ì•„ì›ƒ</button>
			</div>
			
			<!-- Preset Buttons -->
			<button id="headerImportBtn" style="padding:6px 12px; font-size:13px" data-text-ko="ğŸ“¥ ë¶ˆëŸ¬ì˜¤ê¸°" data-text-en="ğŸ“¥ Import">ğŸ“¥ ë¶ˆëŸ¬ì˜¤ê¸°</button>
			<button id="headerExportBtn" class="primary" style="padding:6px 12px; font-size:13px" data-text-ko="ğŸ“¤ ë‚´ë³´ë‚´ê¸°" data-text-en="ğŸ“¤ Export">ğŸ“¤ ë‚´ë³´ë‚´ê¸°</button>
		</div>

		<div class="panel">
			<div class="row">
				<div class="help" id="settingsLabel" data-text-ko="ì„¤ì •" data-text-en="Settings">ì„¤ì •</div>
				<button id="openUnifiedStyle" class="right primary" data-text-ko="ğŸ¨ í‚¤ ìŠ¤íƒ€ì¼" data-text-en="ğŸ¨ Key Style">ğŸ¨ í‚¤ ìŠ¤íƒ€ì¼</button>
				<button id="openOverlayCfg" data-text-ko="âš™ï¸ ì˜¤ë²„ë ˆì´" data-text-en="âš™ï¸ Overlay">âš™ï¸ ì˜¤ë²„ë ˆì´</button>
			</div>
		</div>

		<div class="panel">
			<div class="help">
				<span class="badge" id="modeExplanationLabel" data-text-ko="ëª¨ë“œ ì„¤ëª…" data-text-en="Mode Explanation">ëª¨ë“œ ì„¤ëª…</span>
				<div id="modeExplanation1" data-text-ko="- ì œëª©: ìœˆë„ìš° ì œëª©ì— ê°’ì´ í¬í•¨ë˜ë©´ ë§¤ì¹­" data-text-en="- Title: Matches when window title contains the value">- ì œëª©: ìœˆë„ìš° ì œëª©ì— ê°’ì´ í¬í•¨ë˜ë©´ ë§¤ì¹­</div>
				<div id="modeExplanation2" data-text-ko="- í”„ë¡œì„¸ìŠ¤: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ ë§¤ì¹­ (ì˜ˆ: notepad.exe)" data-text-en="- Process: Must exactly match process name (e.g., notepad.exe)">- í”„ë¡œì„¸ìŠ¤: í”„ë¡œì„¸ìŠ¤ ì´ë¦„ê³¼ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ ë§¤ì¹­ (ì˜ˆ: notepad.exe)</div>
				<div id="modeExplanation3" data-text-ko="- HWND: íŠ¹ì • ì°½ í•¸ë“¤ê³¼ ì¼ì¹˜" data-text-en="- HWND: Matches specific window handle">- HWND: íŠ¹ì • ì°½ í•¸ë“¤ê³¼ ì¼ì¹˜</div>
				<div id="modeExplanation4" data-text-ko="- í´ë˜ìŠ¤: ìœˆë„ìš° í´ë˜ìŠ¤ëª…ê³¼ ì •í™•íˆ ì¼ì¹˜ (ë™ì¼ ìœ í˜•ì˜ ì°½ ì „ì²´)" data-text-en="- Class: Must exactly match window class name (all windows of same type)">- í´ë˜ìŠ¤: ìœˆë„ìš° í´ë˜ìŠ¤ëª…ê³¼ ì •í™•íˆ ì¼ì¹˜ (ë™ì¼ ìœ í˜•ì˜ ì°½ ì „ì²´)</div>
				<div id="modeExplanation5" data-text-ko="- ëª¨ë“  ì°½: ëª¨ë“  í¬ì»¤ìŠ¤ ì°½ì—ì„œ ì…ë ¥ì„ ê°ì§€" data-text-en="- All Windows: Detects input in all focused windows">- ëª¨ë“  ì°½: ëª¨ë“  í¬ì»¤ìŠ¤ ì°½ì—ì„œ ì…ë ¥ì„ ê°ì§€</div>
			</div>
		</div>

		<div class="panel">
			<div class="row">
				<label id="modeLabel" data-text-ko="ëª¨ë“œ" data-text-en="Mode">ëª¨ë“œ</label>
				<select id="mode">
					<option value="disabled" data-text-ko="ì‚¬ìš© ì•ˆ í•¨" data-text-en="Disabled">ì‚¬ìš© ì•ˆ í•¨</option>
					<option value="title" data-text-ko="ì œëª©(í¬í•¨)" data-text-en="Title (Contains)">ì œëª©(í¬í•¨)</option>
					<option value="process" selected data-text-ko="í”„ë¡œì„¸ìŠ¤(ì •í™•)" data-text-en="Process (Exact)">í”„ë¡œì„¸ìŠ¤(ì •í™•)</option>
					<option value="hwnd" data-text-ko="ìœˆë„ìš° í•¸ë“¤(HWND)" data-text-en="Window Handle (HWND)">ìœˆë„ìš° í•¸ë“¤(HWND)</option>
					<option value="class" data-text-ko="í´ë˜ìŠ¤ ëª…(ì •í™•)" data-text-en="Class Name (Exact)">í´ë˜ìŠ¤ ëª…(ì •í™•)</option>
					<option value="all" data-text-ko="ëª¨ë“  ì°½" data-text-en="All Windows">ëª¨ë“  ì°½</option>
				</select>
				<label id="valueSelectLabel" data-text-ko="ê°’ ì„ íƒ" data-text-en="Value Selection">ê°’ ì„ íƒ</label>
				<select id="valuePick" style="min-width:220px"><option value="" data-text-ko="ì„ íƒ..." data-text-en="Select...">ì„ íƒ...</option></select>
				<button id="apply" class="primary" data-text-ko="ì ìš©" data-text-en="Apply">ì ìš©</button>
				<div id="status" class="right help"></div>
			</div>
			<div class="help" style="margin-top:8px; padding:8px; background:var(--panel2); border-radius:6px;">
				<strong id="currentSelectionLabel" data-text-ko="í˜„ì¬ ì„ íƒ ìƒíƒœ:" data-text-en="Current Selection Status:">í˜„ì¬ ì„ íƒ ìƒíƒœ:</strong><br>
				<span id="modeStatusLabel" data-text-ko="ëª¨ë“œ:" data-text-en="Mode:">ëª¨ë“œ:</span> <span id="debugMode" class="badge">-</span><br>
				<span id="selectedValueLabel" data-text-ko="ì €ì¥ëœ ê°’:" data-text-en="Saved Value:">ì €ì¥ëœ ê°’:</span> <span id="debugValue" class="badge">-</span><br>
				<span id="applyStatusLabel" data-text-ko="ì ìš© ìƒíƒœ:" data-text-en="Apply Status:">ì ìš© ìƒíƒœ:</span> <span id="debugStatus" class="badge">-</span>
			</div>
		</div>

		<div class="panel">
			<div class="row" style="margin-bottom:8px">
				<div class="help" id="currentFocusLabel" data-text-ko="í˜„ì¬ í¬ì»¤ìŠ¤ ì°½" data-text-en="Current Focus Window">í˜„ì¬ í¬ì»¤ìŠ¤ ì°½</div>
			</div>
			<div class="help" id="fginfo" data-text-ko="ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘..." data-text-en="Loading...">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
		</div>

		<div class="panel">
			<div class="row" style="margin-bottom:8px">
				<div class="help" id="openWindowsLabel" data-text-ko="í˜„ì¬ ì—´ë ¤ìˆëŠ” ì°½ (ì„ íƒí•˜ë©´ ì ìš©ë¨)" data-text-en="Currently Open Windows (Click to apply)">í˜„ì¬ ì—´ë ¤ìˆëŠ” ì°½ (ì„ íƒí•˜ë©´ ì ìš©ë¨)</div>
			</div>
			<table>
				<colgroup>
					<col style="width:46%"/>
					<col style="width:18%"/>
					<col style="width:12%"/>
					<col style="width:16%"/>
				</colgroup>
				<thead>
					<tr>
						<th id="th_title" data-key="title" class="sortable" data-text-ko="ì œëª©" data-text-en="Title">ì œëª© <span class="arrow" id="arrow_title"></span></th>
						<th id="th_process" data-key="process" class="sortable" data-text-ko="í”„ë¡œì„¸ìŠ¤" data-text-en="Process">í”„ë¡œì„¸ìŠ¤ <span class="arrow" id="arrow_process"></span></th>
						<th id="th_hwnd" data-key="hwnd" class="sortable" data-text-ko="HWND" data-text-en="HWND">HWND <span class="arrow" id="arrow_hwnd"></span></th>
						<th id="th_class" data-key="class" class="sortable" data-text-ko="í´ë˜ìŠ¤" data-text-en="Class">í´ë˜ìŠ¤ <span class="arrow" id="arrow_class"></span></th>
					</tr>
				</thead>
				<tbody id="winTableBody"></tbody>
			</table>
		</div>
	</div>

	<div class="modal-backdrop" id="modalAll">
		<div class="modal">
			<div class="modal-header">
				<h3 id="warningTitle" data-text-ko="ì£¼ì˜!" data-text-en="Warning!">ì£¼ì˜!</h3>
			</div>
			<div class="modal-content">
				<p style="font-size:18px; line-height:1.5" id="warningMessage" data-text-ko="í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ë©´ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì—ì„œ ì˜¤ë²„ë ˆì´ê°€ ì‘ë™í•´ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤!" data-text-en="Using this feature may cause overlay to work during password input, which could cause problems!">í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ë©´ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì—ì„œ ì˜¤ë²„ë ˆì´ê°€ ì‘ë™í•´ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤!</p>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="saveAll" class="danger" disabled data-text-ko="í™œì„±í™”" data-text-en="Activate">í™œì„±í™”</button>
					<span class="spacer"></span>
					<button id="cancelAll" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Key Image Settings Modal -->
	<div class="modal-backdrop" id="modalKeyImage">
		<div class="modal" style="width:700px">
			<div class="modal-header">
				<h3 id="keyImageTitle" data-text-ko="í‚¤ ì´ë¯¸ì§€ ì„¤ì •" data-text-en="Key Image Settings">í‚¤ ì´ë¯¸ì§€ ì„¤ì •</h3>
			</div>
			<div class="modal-content">
				<!-- Global Settings -->
				<div style="margin-bottom:16px; padding:12px; background:var(--panel2); border-radius:8px">
					<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸŒ ì „ì²´ ì„¤ì •" data-text-en="ğŸŒ Global Settings">ğŸŒ ì „ì²´ ì„¤ì •</div>
					<div class="form-row">
						<label data-text-ko="ê¸°ë³¸ ì´ë¯¸ì§€" data-text-en="Default Image">ê¸°ë³¸ ì´ë¯¸ì§€</label>
						<div class="field" style="display:flex; gap:8px; align-items:center">
							<input type="file" id="ki_default_img" accept="image/*" style="flex:1"/>
							<button id="ki_default_clear" class="danger" style="padding:6px 10px; font-size:12px" data-text-ko="ì‚­ì œ" data-text-en="Remove">ì‚­ì œ</button>
						</div>
					</div>
					<div class="form-row">
						<label data-text-ko="ê¸°ë³¸ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide Text by Default">ê¸°ë³¸ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</label>
						<div class="field"><input type="checkbox" id="ki_default_hide"/> <span class="help" data-text-ko="ì²´í¬í•˜ë©´ ëª¨ë“  í‚¤ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Check to hide all key text">ì²´í¬í•˜ë©´ ëª¨ë“  í‚¤ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</span></div>
					</div>
					<div id="ki_default_preview" style="margin-top:8px; display:none">
						<span style="font-size:12px; opacity:0.7" data-text-ko="ë¯¸ë¦¬ë³´ê¸°:" data-text-en="Preview:">ë¯¸ë¦¬ë³´ê¸°:</span>
						<img id="ki_default_preview_img" style="max-height:48px; max-width:100px; border-radius:6px; vertical-align:middle; margin-left:8px"/>
					</div>
				</div>

				<!-- Per-Key Settings -->
				<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸ¹ ê°œë³„ í‚¤ ì„¤ì •" data-text-en="ğŸ¹ Per-Key Settings">ğŸ¹ ê°œë³„ í‚¤ ì„¤ì •</div>
				<div class="form-row">
					<label data-text-ko="í‚¤ ì„ íƒ" data-text-en="Select Key">í‚¤ ì„ íƒ</label>
					<select id="ki_key_select" class="field" style="min-width:120px">
						<option value="">-- í‚¤ ì„ íƒ --</option>
					</select>
					<button id="ki_add_custom" style="padding:6px 12px" data-text-ko="+ ì§ì ‘ ì…ë ¥" data-text-en="+ Custom">+ ì§ì ‘ ì…ë ¥</button>
				</div>
				
				<div id="ki_key_config" style="display:none; margin-top:12px; padding:12px; background:var(--panel2); border-radius:8px">
					<div style="font-weight:600; margin-bottom:10px"><span data-text-ko="í‚¤:" data-text-en="Key:">í‚¤:</span> <span id="ki_selected_key" class="badge"></span></div>
					<div class="form-row">
						<label data-text-ko="ì´ë¯¸ì§€" data-text-en="Image">ì´ë¯¸ì§€</label>
						<div class="field" style="display:flex; gap:8px; align-items:center">
							<input type="file" id="ki_key_img" accept="image/*" style="flex:1"/>
							<button id="ki_key_clear" class="danger" style="padding:6px 10px; font-size:12px" data-text-ko="ì‚­ì œ" data-text-en="Remove">ì‚­ì œ</button>
						</div>
					</div>
					<div class="form-row">
						<label data-text-ko="í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide Text">í…ìŠ¤íŠ¸ ìˆ¨ê¹€</label>
						<div class="field"><input type="checkbox" id="ki_key_hide"/> <span class="help" data-text-ko="ì´ í‚¤ë§Œ í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide text for this key only">ì´ í‚¤ë§Œ í…ìŠ¤íŠ¸ ìˆ¨ê¹€</span></div>
					</div>
					<div id="ki_key_preview" style="margin-top:8px; display:none">
						<span style="font-size:12px; opacity:0.7" data-text-ko="ë¯¸ë¦¬ë³´ê¸°:" data-text-en="Preview:">ë¯¸ë¦¬ë³´ê¸°:</span>
						<img id="ki_key_preview_img" style="max-height:48px; max-width:100px; border-radius:6px; vertical-align:middle; margin-left:8px"/>
					</div>
					<button id="ki_key_save" class="primary" style="margin-top:10px" data-text-ko="ì´ í‚¤ ì €ì¥" data-text-en="Save This Key">ì´ í‚¤ ì €ì¥</button>
				</div>

				<!-- Configured Keys List -->
				<div style="margin-top:16px">
					<div style="font-weight:600; margin-bottom:10px" data-text-ko="ğŸ“‹ ì„¤ì •ëœ í‚¤ ëª©ë¡" data-text-en="ğŸ“‹ Configured Keys">ğŸ“‹ ì„¤ì •ëœ í‚¤ ëª©ë¡</div>
					<div id="ki_configured_list" style="max-height:200px; overflow-y:auto; background:var(--panel2); border-radius:8px; padding:8px">
						<div class="help" style="text-align:center; padding:20px" data-text-ko="ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤" data-text-en="No keys configured">ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤</div>
					</div>
				</div>

				<!-- Preview -->
				<div class="overlay-preview" style="margin-top:16px">
					<div class="help" style="margin-bottom:8px" data-text-ko="ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°" data-text-en="Live Preview">ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸°</div>
					<div class="queue" id="ki_preview_queue" style="display:grid; grid-template-columns:repeat(4, max-content); gap:8px"></div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="ki_clear_all" class="danger" data-text-ko="ì „ì²´ ì´ˆê¸°í™”" data-text-en="Clear All">ì „ì²´ ì´ˆê¸°í™”</button>
					<span class="spacer"></span>
					<button id="closeKeyImage" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Image Crop Modal -->
	<div class="modal-backdrop" id="modalCrop" style="z-index:1001">
		<div class="modal" style="width:600px">
			<div class="modal-header">
				<h3 data-text-ko="ì´ë¯¸ì§€ ìë¥´ê¸°" data-text-en="Crop Image">ì´ë¯¸ì§€ ìë¥´ê¸°</h3>
			</div>
			<div class="modal-content">
				<div class="crop-container" id="cropContainer">
					<canvas id="cropCanvas" class="crop-canvas"></canvas>
					<canvas id="cropOverlay" class="crop-overlay"></canvas>
				</div>
				<div class="crop-info" id="cropInfo" data-text-ko="ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •, íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ" data-text-en="Drag to position, scroll to zoom">ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ ì¡°ì •, íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ</div>
				<div class="crop-controls">
					<label data-text-ko="í™•ëŒ€/ì¶•ì†Œ:" data-text-en="Zoom:">í™•ëŒ€/ì¶•ì†Œ:</label>
					<input type="range" id="cropZoom" min="0.5" max="3" step="0.1" value="1"/>
					<span id="cropZoomValue">100%</span>
				</div>
				<div class="crop-controls">
					<span style="font-size:12px; opacity:0.7" data-text-ko="ì¹© í¬ê¸° (ì˜¤ë²„ë ˆì´ ì„¤ì • ê¸°ì¤€):" data-text-en="Chip size (from overlay settings):">ì¹© í¬ê¸° (ì˜¤ë²„ë ˆì´ ì„¤ì • ê¸°ì¤€):</span>
					<span id="cropChipSize" class="badge">-- x -- px</span>
				</div>
				<div style="margin-top:12px; padding:10px; background:var(--panel2); border-radius:8px">
					<div style="font-size:12px; opacity:0.7; margin-bottom:8px" data-text-ko="ğŸ’¡ ì°¸ê³ : ê¸´ í‚¤(SPACE, ENTER ë“±)ë„ ê°™ì€ ì´ë¯¸ì§€ê°€ ì ìš©ë©ë‹ˆë‹¤" data-text-en="ğŸ’¡ Note: Longer keys (SPACE, ENTER, etc.) will use the same image">ğŸ’¡ ì°¸ê³ : ê¸´ í‚¤(SPACE, ENTER ë“±)ë„ ê°™ì€ ì´ë¯¸ì§€ê°€ ì ìš©ë©ë‹ˆë‹¤</div>
					<div style="display:flex; gap:8px; flex-wrap:wrap">
						<div class="badge" style="padding:6px 12px">Q</div>
						<div class="badge" style="padding:6px 24px">SPACE</div>
						<div class="badge" style="padding:6px 18px">ENTER</div>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="cropApply" class="primary" data-text-ko="ì ìš©" data-text-en="Apply">ì ìš©</button>
					<span class="spacer"></span>
					<button id="cropCancel" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
				</div>
			</div>
		</div>
	</div>

	<div class="modal-backdrop" id="modalOverlay">
		<div class="modal">
			<div class="modal-header">
				<h3 id="overlaySettingsTitle" data-text-ko="ì˜¤ë²„ë ˆì´ ì„¤ì •" data-text-en="Overlay Settings">ì˜¤ë²„ë ˆì´ ì„¤ì •</h3>
			</div>
			<div class="modal-content">
				<div class="help" style="margin-bottom:12px; padding:10px; background:var(--panel2); border-radius:6px" data-text-ko="â±ï¸ íƒ€ì´ë° ë° ë ˆì´ì•„ì›ƒ ì„¤ì •" data-text-en="â±ï¸ Timing and Layout Settings">â±ï¸ íƒ€ì´ë° ë° ë ˆì´ì•„ì›ƒ ì„¤ì •</div>
				<div class="form-row"><label id="fadeInLabel" data-text-ko="Fade In(ms)" data-text-en="Fade In(ms)">Fade In(ms)</label><input id="ov_fade_in" class="field" type="number" min="0" step="10"/></div>
				<div class="form-row"><label id="fadeOutLabel" data-text-ko="Fade Out(ms)" data-text-en="Fade Out(ms)">Fade Out(ms)</label><input id="ov_fade_out" class="field" type="number" min="0" step="10"/></div>
				<div class="form-row"><label id="colsLabel" data-text-ko="ì—´(Cols)" data-text-en="Columns(Cols)">ì—´(Cols)</label><input id="ov_cols" class="field" type="number" min="1" step="1"/></div>
				<div class="form-row"><label id="rowsLabel" data-text-ko="í–‰(Rows)" data-text-en="Rows">í–‰(Rows)</label><input id="ov_rows" class="field" type="number" min="0" step="1"/></div>
				<div class="help" id="rowsHelp" data-text-ko="í–‰(Rows)ì— 0ì„ ì…ë ¥í•˜ë©´ ì œí•œ ì—†ì´ ì—¬ëŸ¬ ì¤„ë¡œ ìë™ ê°ìŒ‰ë‹ˆë‹¤." data-text-en="Enter 0 in Rows to automatically wrap to multiple lines without limit.">í–‰(Rows)ì— 0ì„ ì…ë ¥í•˜ë©´ ì œí•œ ì—†ì´ ì—¬ëŸ¬ ì¤„ë¡œ ìë™ ê°ìŒ‰ë‹ˆë‹¤.</div>
				<div class="form-row"><label id="alignLabel" data-text-ko="ì •ë ¬" data-text-en="Alignment">ì •ë ¬</label><select id="ov_align" class="field"><option value="left" selected data-text-ko="ì¢Œì¸¡" data-text-en="Left">ì¢Œì¸¡</option><option value="center" data-text-ko="ì¤‘ì•™" data-text-en="Center">ì¤‘ì•™</option><option value="right" data-text-ko="ìš°ì¸¡" data-text-en="Right">ìš°ì¸¡</option></select></div>
				<div class="form-row"><label id="directionLabel" data-text-ko="ìŒ“ì´ëŠ” ë°©í–¥" data-text-en="Stacking Direction">ìŒ“ì´ëŠ” ë°©í–¥</label><select id="ov_direction" class="field"><option value="ltr" selected data-text-ko="ì™¼â†’ì˜¤ (LTR)" data-text-en="Leftâ†’Right (LTR)">ì™¼â†’ì˜¤ (LTR)</option><option value="rtl" data-text-ko="ì˜¤â†’ì™¼ (RTL)" data-text-en="Rightâ†’Left (RTL)">ì˜¤â†’ì™¼ (RTL)</option></select></div>

				<div style="margin-top:12px; padding:12px; background:var(--panel2); border-radius:8px">
					<div class="form-row" style="margin-bottom:0">
						<label data-text-ko="ğŸ–¼ï¸ í‚¤ ì´ë¯¸ì§€" data-text-en="ğŸ–¼ï¸ Key Images">ğŸ–¼ï¸ í‚¤ ì´ë¯¸ì§€</label>
						<button id="ov_open_key_image" class="field" style="flex:none; padding:8px 16px" data-text-ko="í‚¤ ì´ë¯¸ì§€ ì„¤ì • ì—´ê¸°" data-text-en="Open Key Image Settings">í‚¤ ì´ë¯¸ì§€ ì„¤ì • ì—´ê¸°</button>
					</div>
				</div>

				<div class="overlay-preview" id="ov_preview">
					<div class="help" style="margin-bottom:8px" id="previewLabel" data-text-ko="ë¯¸ë¦¬ë³´ê¸°" data-text-en="Preview">ë¯¸ë¦¬ë³´ê¸°</div>
					<div class="queue" id="ov_preview_queue"></div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="saveOverlay" class="primary" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
					<button id="resetOverlay" data-text-ko="ê¸°ë³¸ê°’" data-text-en="Reset">ê¸°ë³¸ê°’</button>
					<span class="spacer"></span>
					<button id="closeOverlay" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Unified Key Style Settings Modal -->
	<div class="modal-backdrop" id="modalUnifiedStyle">
		<div class="modal" style="width:720px">
			<div class="modal-header">
				<h3 data-text-ko="ğŸ¨ í‚¤ ìŠ¤íƒ€ì¼ ì„¤ì •" data-text-en="ğŸ¨ Key Style Settings">ğŸ¨ í‚¤ ìŠ¤íƒ€ì¼ ì„¤ì •</h3>
			</div>
			<div class="modal-content">
				<!-- Main Tabs -->
				<div class="key-img-tabs" id="unifiedStyleTabs">
					<button id="usTabBg" class="active" data-text-ko="ğŸ“ ë°°ê²½" data-text-en="ğŸ“ Background">ğŸ“ ë°°ê²½</button>
					<button id="usTabChip" data-text-ko="ğŸ² ì¹©" data-text-en="ğŸ² Chip">ğŸ² ì¹©</button>
					<button id="usTabFont" data-text-ko="âœï¸ í°íŠ¸" data-text-en="âœï¸ Font">âœï¸ í°íŠ¸</button>
				</div>

				<!-- ========== Background Tab ========== -->
				<div id="usPanelBg">
					<div class="help" style="margin-bottom:12px" data-text-ko="ì „ì²´ ì˜¤ë²„ë ˆì´ ë°°ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤." data-text-en="Configure the overall overlay background.">ì „ì²´ ì˜¤ë²„ë ˆì´ ë°°ê²½ì„ ì„¤ì •í•©ë‹ˆë‹¤.</div>
					
					<div class="form-row">
						<label data-text-ko="íˆ¬ëª… ë°°ê²½" data-text-en="Transparent">íˆ¬ëª… ë°°ê²½</label>
						<input type="checkbox" id="us_bg_transparent" checked/>
						<span class="help" data-text-ko="ì²´í¬í•˜ë©´ ë°°ê²½ì´ ì™„ì „ íˆ¬ëª… (OBSìš©)" data-text-en="Check for transparent background (for OBS)">ì²´í¬í•˜ë©´ ë°°ê²½ì´ ì™„ì „ íˆ¬ëª… (OBSìš©)</span>
					</div>
					
					<div id="usBgColorSection">
						<div class="form-row">
							<label data-text-ko="ë°°ê²½ ëª¨ë“œ" data-text-en="Mode">ë°°ê²½ ëª¨ë“œ</label>
							<select id="us_bg_mode" class="field">
								<option value="solid" data-text-ko="ë‹¨ìƒ‰" data-text-en="Solid">ë‹¨ìƒ‰</option>
								<option value="gradient" data-text-ko="ê·¸ë¼ë°ì´ì…˜" data-text-en="Gradient">ê·¸ë¼ë°ì´ì…˜</option>
								<option value="image" data-text-ko="ì´ë¯¸ì§€" data-text-en="Image">ì´ë¯¸ì§€</option>
							</select>
						</div>
						<div id="usBgSolid">
							<div class="form-row"><label data-text-ko="ë°°ê²½ìƒ‰" data-text-en="Color">ë°°ê²½ìƒ‰</label><div class="field color-field"><input id="us_bg_color_picker" type="color" value="#000000" style="width:40px;height:32px"/><input id="us_bg_color" type="text" placeholder="#000000" value="#000000" style="flex:1;font-family:monospace"/></div></div>
						</div>
						<div id="usBgGradient" style="display:none">
							<!-- Gradient Direction -->
							<div class="form-row" style="margin-bottom:12px">
								<label data-text-ko="ë°©í–¥" data-text-en="Direction">ë°©í–¥</label>
								<div class="field" style="display:flex; gap:6px; align-items:center">
									<input type="range" id="us_bg_grad_angle" min="0" max="360" value="180" style="flex:1"/>
									<input type="number" id="us_bg_grad_angle_num" min="0" max="360" value="180" style="width:60px"/>
									<span>Â°</span>
								</div>
							</div>
							<!-- Gradient Preview -->
							<div id="us_bg_grad_preview" style="height:24px; border-radius:6px; margin-bottom:12px; border:1px solid var(--border); background:linear-gradient(180deg, #000000, #333333)"></div>
							<!-- Color Stops List -->
							<div class="help" style="margin-bottom:6px; font-weight:600" data-text-ko="ğŸ¨ ìƒ‰ìƒ ì •ì§€ì " data-text-en="ğŸ¨ Color Stops">ğŸ¨ ìƒ‰ìƒ ì •ì§€ì </div>
							<div id="us_bg_grad_stops" style="display:flex; flex-direction:column; gap:6px; margin-bottom:8px">
								<!-- Dynamic color stops will be added here -->
							</div>
							<button id="us_bg_grad_add" style="width:100%; padding:6px" data-text-ko="+ ìƒ‰ìƒ ì¶”ê°€" data-text-en="+ Add Color">+ ìƒ‰ìƒ ì¶”ê°€</button>
						</div>
						<div id="usBgImage" style="display:none">
							<div class="key-img-drop" id="usBgImageDrop" style="padding:20px">
								<div data-text-ko="ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­" data-text-en="Drag image or click">ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­</div>
								<input type="file" id="usBgImageFile" accept="image/*" style="display:none"/>
							</div>
							<div id="usBgImagePreview" style="display:none; margin-top:8px">
								<img id="usBgImagePreviewImg" src="" style="max-width:100%; max-height:100px; border-radius:6px"/>
								<button id="usBgImageClear" class="danger" style="margin-left:8px" data-text-ko="ì œê±°" data-text-en="Remove">ì œê±°</button>
							</div>
						</div>
					</div>
				</div>

				<!-- ========== Chip Tab ========== -->
				<div id="usPanelChip" style="display:none">
					<div class="help" style="margin-bottom:12px" data-text-ko="ì¹©(í‚¤) ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ê´€ë¦¬í•©ë‹ˆë‹¤. ê°œë³„ í‚¤ > ê·¸ë£¹ í‚¤ > ì „ì²´ í‚¤ ìš°ì„ ìˆœìœ„ë¡œ ì ìš©ë©ë‹ˆë‹¤." data-text-en="Manage chip style groups. Priority: Individual > Group > All keys.">ì¹©(í‚¤) ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ê´€ë¦¬í•©ë‹ˆë‹¤. ê°œë³„ í‚¤ > ê·¸ë£¹ í‚¤ > ì „ì²´ í‚¤ ìš°ì„ ìˆœìœ„ë¡œ ì ìš©ë©ë‹ˆë‹¤.</div>
					
					<!-- Chip Layout Settings -->
					<div style="margin-bottom:16px; padding:12px; background:var(--panel2); border-radius:8px">
						<div class="help" style="margin-bottom:10px; font-weight:600" data-text-ko="ğŸ“ ì¹© í¬ê¸°/ê°„ê²©" data-text-en="ğŸ“ Chip Size/Spacing">ğŸ“ ì¹© í¬ê¸°/ê°„ê²©</div>
						<div class="form-row"><label data-text-ko="ì¹© ê°„ê²©(px)" data-text-en="Gap">ì¹© ê°„ê²©(px)</label><input id="us_chip_gap" class="field" type="number" min="0" value="8"/></div>
						<div class="form-row"><label data-text-ko="ì„¸ë¡œ íŒ¨ë”©" data-text-en="Pad V">ì„¸ë¡œ íŒ¨ë”©</label><input id="us_chip_pad_v" class="field" type="number" min="0" value="10"/></div>
						<div class="form-row"><label data-text-ko="ê°€ë¡œ íŒ¨ë”©" data-text-en="Pad H">ê°€ë¡œ íŒ¨ë”©</label><input id="us_chip_pad_h" class="field" type="number" min="0" value="14"/></div>
						<div class="form-row"><label data-text-ko="ëª¨ì„œë¦¬" data-text-en="Radius">ëª¨ì„œë¦¬</label><input id="us_chip_radius" class="field" type="number" min="0" value="10"/></div>
					</div>
					
					<!-- Style Groups List -->
					<div style="margin-bottom:16px; padding:12px; background:var(--panel2); border-radius:8px">
						<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
							<div class="help" style="font-weight:600" data-text-ko="ğŸ“¦ ìŠ¤íƒ€ì¼ ê·¸ë£¹" data-text-en="ğŸ“¦ Style Groups">ğŸ“¦ ìŠ¤íƒ€ì¼ ê·¸ë£¹</div>
							<button id="usAddGroup" class="primary" style="padding:4px 10px; font-size:12px" data-text-ko="+ ìƒˆ ê·¸ë£¹" data-text-en="+ New Group">+ ìƒˆ ê·¸ë£¹</button>
						</div>
						<div id="usGroupList" class="key-img-list" style="max-height:200px">
							<div class="help" style="text-align:center; padding:20px; color:var(--muted)" id="usNoGroups" data-text-ko="ë“±ë¡ëœ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤" data-text-en="No style groups registered">ë“±ë¡ëœ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì´ ì—†ìŠµë‹ˆë‹¤</div>
						</div>
					</div>
					
					<!-- Group Editor (hidden by default) -->
					<div id="usGroupEditor" style="display:none; padding:12px; background:var(--panel2); border-radius:8px; border:2px solid var(--primary)">
						<div class="help" style="margin-bottom:10px; font-weight:600" data-text-ko="âœï¸ ê·¸ë£¹ í¸ì§‘" data-text-en="âœï¸ Edit Group">âœï¸ ê·¸ë£¹ í¸ì§‘</div>
						<input type="hidden" id="usGroupEditId"/>
						<div class="form-row"><label data-text-ko="ê·¸ë£¹ ì´ë¦„" data-text-en="Name">ê·¸ë£¹ ì´ë¦„</label><input id="usGroupName" class="field" type="text" placeholder="My Group"/></div>
						<div class="form-row">
							<label data-text-ko="ê·¸ë£¹ ìœ í˜•" data-text-en="Type">ê·¸ë£¹ ìœ í˜•</label>
							<select id="usGroupType" class="field">
								<option value="individual" data-text-ko="ê°œë³„ í‚¤" data-text-en="Individual Keys">ê°œë³„ í‚¤</option>
								<option value="group" data-text-ko="ê·¸ë£¹ í‚¤" data-text-en="Group Keys">ê·¸ë£¹ í‚¤</option>
								<option value="all" data-text-ko="ëª¨ë“  í‚¤" data-text-en="All Keys">ëª¨ë“  í‚¤</option>
							</select>
						</div>
						<div id="usGroupKeysSection">
							<div class="form-row">
								<label data-text-ko="í‚¤ ì„ íƒ" data-text-en="Keys">í‚¤ ì„ íƒ</label>
								<button id="usRecordKeys" data-text-ko="ğŸ¤ ë…¹í™”" data-text-en="ğŸ¤ Record">ğŸ¤ ë…¹í™”</button>
								<span id="usRecordedKeys" style="margin-left:8px; font-size:12px; color:var(--muted)"></span>
							</div>
							<div class="form-row" style="margin-top:6px">
								<label data-text-ko="ë§ˆìš°ìŠ¤" data-text-en="Mouse">ë§ˆìš°ìŠ¤</label>
								<button type="button" id="usMouseLMB" onclick="toggleMouseButton('LMB')" class="mouse-btn" style="padding:4px 8px; font-size:11px">ğŸ–±ï¸ ì¢Œí´ë¦­</button>
								<button type="button" id="usMouseRMB" onclick="toggleMouseButton('RMB')" class="mouse-btn" style="padding:4px 8px; font-size:11px">ğŸ–±ï¸ ìš°í´ë¦­</button>
								<button type="button" id="usMouseMMB" onclick="toggleMouseButton('MMB')" class="mouse-btn" style="padding:4px 8px; font-size:11px">ğŸ–±ï¸ ì¤‘ê°„</button>
								<button type="button" id="usMouseM4" onclick="toggleMouseButton('MOUSE4')" class="mouse-btn" style="padding:4px 8px; font-size:11px">M4</button>
								<button type="button" id="usMouseM5" onclick="toggleMouseButton('MOUSE5')" class="mouse-btn" style="padding:4px 8px; font-size:11px">M5</button>
							</div>
						</div>
						<div class="form-row">
							<label data-text-ko="ì¹© ë°°ê²½" data-text-en="Chip BG">ì¹© ë°°ê²½</label>
							<select id="usGroupBgMode" class="field">
								<option value="transparent" data-text-ko="íˆ¬ëª…" data-text-en="Transparent">íˆ¬ëª…</option>
								<option value="solid" data-text-ko="ë‹¨ìƒ‰" data-text-en="Solid">ë‹¨ìƒ‰</option>
								<option value="gradient" data-text-ko="ê·¸ë¼ë°ì´ì…˜" data-text-en="Gradient">ê·¸ë¼ë°ì´ì…˜</option>
								<option value="image" data-text-ko="ì´ë¯¸ì§€" data-text-en="Image">ì´ë¯¸ì§€</option>
							</select>
						</div>
						<div id="usGroupBgSolid" style="display:none">
							<div class="form-row"><label data-text-ko="ìƒ‰ìƒ" data-text-en="Color">ìƒ‰ìƒ</label><div class="field color-field"><input id="usGroupBgColor_picker" type="color" value="#000000" style="width:40px;height:32px"/><input id="usGroupBgColor" type="text" value="#000000" style="flex:1;font-family:monospace"/></div></div>
						</div>
						<div id="usGroupBgGrad" style="display:none">
							<!-- Gradient Direction -->
							<div class="form-row" style="margin-bottom:10px">
								<label data-text-ko="ë°©í–¥" data-text-en="Direction">ë°©í–¥</label>
								<div class="field" style="display:flex; gap:6px; align-items:center">
									<input type="range" id="usGroupGradAngle" min="0" max="360" value="180" style="flex:1"/>
									<input type="number" id="usGroupGradAngleNum" min="0" max="360" value="180" style="width:55px"/>
									<span>Â°</span>
								</div>
							</div>
							<!-- Gradient Preview -->
							<div id="usGroupGradPreview" style="height:20px; border-radius:4px; margin-bottom:10px; border:1px solid var(--border); background:linear-gradient(180deg, #000000, #333333)"></div>
							<!-- Color Stops List -->
							<div class="help" style="margin-bottom:6px; font-size:11px; font-weight:600" data-text-ko="ğŸ¨ ìƒ‰ìƒ" data-text-en="ğŸ¨ Colors">ğŸ¨ ìƒ‰ìƒ</div>
							<div id="usGroupGradStops" style="display:flex; flex-direction:column; gap:4px; margin-bottom:6px"></div>
							<button id="usGroupGradAdd" style="width:100%; padding:4px; font-size:12px" data-text-ko="+ ìƒ‰ìƒ ì¶”ê°€" data-text-en="+ Add Color">+ ìƒ‰ìƒ ì¶”ê°€</button>
						</div>
						<div id="usGroupBgImage" style="display:none">
							<div class="key-img-drop" id="usGroupImageDrop" style="padding:16px">
								<div data-text-ko="ì´ë¯¸ì§€ ì—…ë¡œë“œ" data-text-en="Upload Image">ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
								<input type="file" id="usGroupImageFile" accept="image/*" style="display:none"/>
							</div>
							<img id="usGroupImagePreview" src="" style="display:none; max-width:100px; margin-top:8px; border-radius:6px"/>
						</div>
						<div style="display:flex; gap:8px; margin-top:12px">
							<button id="usGroupSave" class="primary" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
							<button id="usGroupCancel" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
						</div>
					</div>
				</div>

				<!-- ========== Font Tab ========== -->
				<div id="usPanelFont" style="display:none">
					<div class="help" style="margin-bottom:12px" data-text-ko="ê¸°ë³¸ í°íŠ¸ì™€ ê·¸ë£¹ë³„ í°íŠ¸ ì˜¤ë²„ë¼ì´ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤." data-text-en="Configure default font and group-specific font overrides.">ê¸°ë³¸ í°íŠ¸ì™€ ê·¸ë£¹ë³„ í°íŠ¸ ì˜¤ë²„ë¼ì´ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.</div>
					
					<!-- Default Font -->
					<div style="margin-bottom:16px; padding:12px; background:var(--panel2); border-radius:8px">
						<div class="help" style="margin-bottom:10px; font-weight:600" data-text-ko="ğŸ”¤ ê¸°ë³¸ í°íŠ¸" data-text-en="ğŸ”¤ Default Font">ğŸ”¤ ê¸°ë³¸ í°íŠ¸</div>
						<div class="form-row">
							<label data-text-ko="í°íŠ¸" data-text-en="Font">í°íŠ¸</label>
							<select id="us_font_family" class="field">
								<option value="system-ui">System UI</option>
								<option value="Arial">Arial</option>
								<option value="'Segoe UI'">Segoe UI</option>
								<option value="Roboto">Roboto</option>
								<option value="'Noto Sans KR'">Noto Sans KR</option>
								<option value="custom">ì»¤ìŠ¤í…€ URL...</option>
							</select>
						</div>
						<div id="usFontUrlSection" style="display:none">
							<div class="form-row"><label>URL</label><input id="us_font_url" class="field" type="text" placeholder="https://fonts.googleapis.com/css2?family=..."/></div>
							<div class="help" style="font-size:11px" data-text-ko="ğŸ’¡ Google Fontsì—ì„œ @import URLì„ ë³µì‚¬í•˜ì„¸ìš”" data-text-en="ğŸ’¡ Copy @import URL from Google Fonts">ğŸ’¡ Google Fontsì—ì„œ @import URLì„ ë³µì‚¬í•˜ì„¸ìš”</div>
						</div>
						<div class="form-row"><label data-text-ko="í¬ê¸°(px)" data-text-en="Size">í¬ê¸°(px)</label><input id="us_font_size" class="field" type="number" min="8" value="24"/></div>
						<div class="form-row"><label data-text-ko="ë‘ê»˜" data-text-en="Weight">ë‘ê»˜</label><select id="us_font_weight" class="field">
							<option value="400">400 (Normal)</option>
							<option value="500">500 (Medium)</option>
							<option value="600">600 (Semi Bold)</option>
							<option value="700" selected>700 (Bold)</option>
							<option value="800">800 (Extra Bold)</option>
							<option value="900">900 (Black)</option>
						</select></div>
						<div class="form-row"><label data-text-ko="ìƒ‰ìƒ" data-text-en="Color">ìƒ‰ìƒ</label><div class="field color-field"><input id="us_font_color_picker" type="color" value="#ffffff" style="width:40px;height:32px"/><input id="us_font_color" type="text" value="#ffffff" style="flex:1;font-family:monospace"/></div></div>
						<div class="form-row"><label data-text-ko="ê·¸ë¦¼ì" data-text-en="Shadow">ê·¸ë¦¼ì</label><input type="checkbox" id="us_font_shadow" checked/></div>
					</div>
					
					<!-- Group Font Overrides -->
					<div style="padding:12px; background:var(--panel2); border-radius:8px">
						<div class="help" style="margin-bottom:10px; font-weight:600" data-text-ko="ğŸ¯ ê·¸ë£¹ë³„ í°íŠ¸ ì˜¤ë²„ë¼ì´ë“œ" data-text-en="ğŸ¯ Group Font Overrides">ğŸ¯ ê·¸ë£¹ë³„ í°íŠ¸ ì˜¤ë²„ë¼ì´ë“œ</div>
						<div id="usGroupFontList">
							<div class="help" style="text-align:center; padding:16px; color:var(--muted)" data-text-ko="ì¹© íƒ­ì—ì„œ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”" data-text-en="Add style groups in Chip tab first">ì¹© íƒ­ì—ì„œ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”</div>
						</div>
						
						<!-- Group Font Editor (hidden by default) -->
						<div id="usGroupFontEditor" style="display:none; margin-top:12px; padding:12px; background:var(--panel); border-radius:8px; border:1px solid var(--primary)">
							<input type="hidden" id="usGroupFontEditId"/>
							<div class="help" style="margin-bottom:10px; font-weight:600; color:var(--primary)" id="usGroupFontEditTitle">í°íŠ¸ ì„¤ì •</div>
							
							<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
								<div class="form-group">
									<label data-text-ko="í°íŠ¸" data-text-en="Font">í°íŠ¸</label>
									<input type="text" id="usGroupFontFamily" placeholder="Arial, sans-serif"/>
									<div class="help" style="font-size:10px; margin-top:2px" data-text-ko="ë¹„ì›Œë‘ë©´ ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©" data-text-en="Leave empty for default">ë¹„ì›Œë‘ë©´ ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©</div>
								</div>
								<div class="form-group">
									<label data-text-ko="í¬ê¸° (px)" data-text-en="Size (px)">í¬ê¸° (px)</label>
									<input type="number" id="usGroupFontSize" min="8" max="72" placeholder="24"/>
								</div>
								<div class="form-group">
									<label data-text-ko="ë‘ê»˜" data-text-en="Weight">ë‘ê»˜</label>
									<select id="usGroupFontWeight">
										<option value="">ê¸°ë³¸ê°’</option>
										<option value="400">400 (Normal)</option>
										<option value="500">500 (Medium)</option>
										<option value="600">600 (Semi-bold)</option>
										<option value="700">700 (Bold)</option>
										<option value="800">800 (Extra-bold)</option>
										<option value="900">900 (Black)</option>
									</select>
								</div>
								<div class="form-group">
									<label data-text-ko="ìƒ‰ìƒ" data-text-en="Color">ìƒ‰ìƒ</label>
									<div style="display:flex; gap:6px; align-items:center">
										<input type="color" id="usGroupFontColor" value="#ffffff" style="width:40px; height:32px"/>
										<input type="text" id="usGroupFontColorText" value="#ffffff" style="flex:1; font-family:monospace"/>
									</div>
								</div>
							</div>
							
							<div style="display:flex; gap:8px; margin-top:12px">
								<button id="usGroupFontSave" class="primary" style="flex:1" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
								<button id="usGroupFontCancel" style="flex:1" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
							</div>
						</div>
					</div>
				</div>

				<!-- Preview -->
				<div class="overlay-preview" id="us_preview" style="margin-top:14px">
					<div class="help" style="margin-bottom:8px" data-text-ko="ë¯¸ë¦¬ë³´ê¸°" data-text-en="Preview">ë¯¸ë¦¬ë³´ê¸°</div>
					<div class="queue" id="us_preview_queue" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center"></div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="usStyleSave" class="primary" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
					<button id="usStyleReset" data-text-ko="ê¸°ë³¸ê°’" data-text-en="Reset">ê¸°ë³¸ê°’</button>
					<span class="spacer"></span>
					<button id="usStyleClose" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>


	<!-- Image Editor Modal -->
	<div id="modalImageEditor" class="modal-backdrop">
		<div class="modal img-editor-modal" style="width:600px">
			<div class="modal-header">
				<h3 data-text-ko="ì´ë¯¸ì§€ í¸ì§‘" data-text-en="Edit Image">ì´ë¯¸ì§€ í¸ì§‘</h3>
			</div>
			<div class="modal-content">
				<!-- Canvas Area with Chip Mask Overlay -->
				<div class="img-editor-canvas-wrap" style="position:relative">
					<canvas id="imgEditorCanvas" class="img-editor-canvas" width="400" height="300"></canvas>
					<!-- Dark overlay with bright chip area -->
					<div id="imgChipMask" style="position:absolute; inset:0; pointer-events:none; display:flex; align-items:center; justify-content:center">
						<div id="imgChipArea" style="border:2px dashed rgba(255,255,255,0.6); background:transparent; border-radius:10px; box-shadow:0 0 0 9999px rgba(0,0,0,0.5)"></div>
					</div>
				</div>

				<!-- Controls -->
				<div class="img-editor-controls">
					<label data-text-ko="í™•ëŒ€" data-text-en="Zoom">í™•ëŒ€</label>
					<input type="range" id="imgZoom" min="50" max="400" value="100"/>
					<span id="imgZoomVal">100%</span>
				</div>
				<input type="hidden" id="imgKeyType" value="medium"/>

				<div class="img-editor-controls">
					<label data-text-ko="í’ˆì§ˆ" data-text-en="Quality">í’ˆì§ˆ</label>
					<input type="range" id="imgQuality" min="30" max="100" value="70"/>
					<span id="imgQualityVal">70%</span>
					<span class="help" style="margin-left:8px" id="imgSizeInfo"></span>
				</div>

				<!-- Preview: Small / Medium / Large -->
				<div class="help" style="margin-bottom:8px" data-text-ko="ë¯¸ë¦¬ë³´ê¸° (ì‘ì€/ì¤‘ê°„/í° ì¹©)" data-text-en="Preview (Small/Medium/Large Chip)">ë¯¸ë¦¬ë³´ê¸° (ì‘ì€/ì¤‘ê°„/í° ì¹©)</div>
				<div class="img-editor-preview" id="editorPreviewContainer" style="gap:16px; align-items:flex-end">
					<div style="text-align:center">
						<div class="editor-preview-chip" id="previewChipSmall">A</div>
						<div class="help" style="font-size:10px; margin-top:4px" data-text-ko="ì‘ì€" data-text-en="Small">ì‘ì€</div>
					</div>
					<div style="text-align:center">
						<div class="editor-preview-chip" id="previewChipMedium">TAB</div>
						<div class="help" style="font-size:10px; margin-top:4px" data-text-ko="ì¤‘ê°„" data-text-en="Medium">ì¤‘ê°„</div>
					</div>
					<div style="text-align:center">
						<div class="editor-preview-chip" id="previewChipLarge">LSHIFT</div>
						<div class="help" style="font-size:10px; margin-top:4px" data-text-ko="í°" data-text-en="Large">í°</div>
					</div>
				</div>

				<!-- Text Visibility -->
				<div style="margin-top:14px; padding:12px; background:var(--panel2); border-radius:8px">
					<div class="form-row" style="margin:0">
						<label data-text-ko="í…ìŠ¤íŠ¸ ìˆ¨ê¹€" data-text-en="Hide Text">í…ìŠ¤íŠ¸ ìˆ¨ê¹€</label>
						<input type="checkbox" id="imgHideText"/>
						<span class="help" data-text-ko="ì²´í¬í•˜ë©´ ì´ë¯¸ì§€ë§Œ í‘œì‹œ" data-text-en="Check to show image only">ì²´í¬í•˜ë©´ ì´ë¯¸ì§€ë§Œ í‘œì‹œ</span>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="imgEditorSave" class="primary" data-text-ko="ì ìš©" data-text-en="Apply">ì ìš©</button>
					<span class="spacer"></span>
					<button id="imgEditorCancel" data-text-ko="ì·¨ì†Œ" data-text-en="Cancel">ì·¨ì†Œ</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Import Modal -->
	<div class="modal-backdrop" id="modalImport">
		<div class="modal" style="width:520px">
			<div class="modal-header">
				<h3 data-text-ko="í”„ë¦¬ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°" data-text-en="Import Preset">í”„ë¦¬ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°</h3>
			</div>
			<div class="modal-content">
				<!-- Gist List (if logged in) -->
				<div id="importGistSection">
					<div class="help" style="margin-bottom:10px" data-text-ko="ë‚´ ì €ì¥ëœ í”„ë¦¬ì…‹" data-text-en="My Saved Presets">ë‚´ ì €ì¥ëœ í”„ë¦¬ì…‹</div>
					<div id="gistListContainer" class="key-img-list" style="max-height:200px">
						<div class="help" style="text-align:center; padding:12px" data-text-ko="ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤" data-text-en="Login required">ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤</div>
					</div>
					
					<!-- Selected Gist Preview -->
					<div id="gistPreviewSection" style="display:none; margin-top:12px; padding:12px; background:var(--panel2); border-radius:8px">
						<div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px">
							<div>
								<div id="gistPreviewName" style="font-weight:600; margin-bottom:4px"></div>
								<div id="gistPreviewDate" class="help" style="font-size:11px"></div>
							</div>
							<button id="loadSelectedGist" class="primary" style="padding:6px 12px; font-size:12px" data-text-ko="ë¶ˆëŸ¬ì˜¤ê¸°" data-text-en="Load">ë¶ˆëŸ¬ì˜¤ê¸°</button>
						</div>
						<div id="gistPreviewInfo" class="help" style="font-size:12px"></div>
					</div>
				</div>

				<div class="or-divider" data-text-ko="ë˜ëŠ”" data-text-en="or">ë˜ëŠ”</div>

				<!-- Gist ID Import -->
				<div class="gist-section" style="border-top:none; padding-top:0; margin-top:0">
					<label data-text-ko="Gist IDë¡œ ë¶ˆëŸ¬ì˜¤ê¸°" data-text-en="Import from Gist ID">Gist IDë¡œ ë¶ˆëŸ¬ì˜¤ê¸°</label>
					<div style="display:flex; gap:8px; margin-top:6px">
						<input id="gistImportId" type="text" placeholder="abc123def456..." style="flex:1"/>
						<button id="gistImportBtn" class="primary" data-text-ko="ë¶ˆëŸ¬ì˜¤ê¸°" data-text-en="Import">ë¶ˆëŸ¬ì˜¤ê¸°</button>
					</div>
				</div>

				<!-- JSON Import -->
				<div class="gist-section">
					<label data-text-ko="JSON ë¶™ì—¬ë„£ê¸°" data-text-en="Paste JSON">JSON ë¶™ì—¬ë„£ê¸°</label>
					<div style="margin-top:6px">
						<button id="jsonImportBtn" style="width:100%" data-text-ko="ğŸ“‹ í´ë¦½ë³´ë“œì—ì„œ ë¶™ì—¬ë„£ê¸°" data-text-en="ğŸ“‹ Paste from Clipboard">ğŸ“‹ í´ë¦½ë³´ë“œì—ì„œ ë¶™ì—¬ë„£ê¸°</button>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<button id="refreshGistList" data-text-ko="ìƒˆë¡œê³ ì¹¨" data-text-en="Refresh">ìƒˆë¡œê³ ì¹¨</button>
					<span class="spacer"></span>
					<button id="closeImport" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Export Modal -->
	<div class="modal-backdrop" id="modalExport">
		<div class="modal" style="width:480px">
			<div class="modal-header">
				<h3 data-text-ko="í”„ë¦¬ì…‹ ë‚´ë³´ë‚´ê¸°" data-text-en="Export Preset">í”„ë¦¬ì…‹ ë‚´ë³´ë‚´ê¸°</h3>
			</div>
			<div class="modal-content">
				<!-- Current Settings Preview -->
				<div style="padding:12px; background:var(--panel2); border-radius:8px; margin-bottom:14px">
					<div class="help" style="margin-bottom:8px; font-weight:600" data-text-ko="ğŸ“¦ í˜„ì¬ ì„¤ì • ë¯¸ë¦¬ë³´ê¸°" data-text-en="ğŸ“¦ Current Settings Preview">ğŸ“¦ í˜„ì¬ ì„¤ì • ë¯¸ë¦¬ë³´ê¸°</div>
					<div id="exportPreviewInfo" class="help" style="font-size:12px; line-height:1.6"></div>
				</div>

				<!-- Gist Export (if logged in) -->
				<div id="exportGistSection">
					<div class="gist-section" style="border-top:none; padding-top:0">
						<label data-text-ko="GitHub Gistë¡œ ì €ì¥" data-text-en="Save to GitHub Gist">GitHub Gistë¡œ ì €ì¥</label>
						<div style="display:flex; gap:8px; margin-top:6px">
							<input id="gistExportDesc" type="text" placeholder="My KeyViewer Preset" data-placeholder-ko="í”„ë¦¬ì…‹ ì´ë¦„" data-placeholder-en="Preset name" style="flex:1"/>
							<button id="gistExportBtn" class="primary" data-text-ko="ì €ì¥" data-text-en="Save">ì €ì¥</button>
						</div>
						<div id="gistExportResult" class="help" style="margin-top:8px; display:none"></div>
					</div>
				</div>

				<div id="exportLoginRequired" style="display:none; padding:12px; background:var(--panel2); border-radius:8px; margin-bottom:14px">
					<div class="help" data-text-ko="Gist ì €ì¥ì„ ìœ„í•´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤" data-text-en="Login required to save to Gist">Gist ì €ì¥ì„ ìœ„í•´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤</div>
				</div>

				<div class="or-divider" data-text-ko="ë˜ëŠ”" data-text-en="or">ë˜ëŠ”</div>

				<!-- JSON Export -->
				<div class="gist-section" style="border-top:none; padding-top:0; margin-top:0">
					<label data-text-ko="JSONìœ¼ë¡œ ë³µì‚¬" data-text-en="Copy as JSON">JSONìœ¼ë¡œ ë³µì‚¬</label>
					<div style="margin-top:6px">
						<button id="jsonExportBtn" style="width:100%" data-text-ko="ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬" data-text-en="ğŸ“‹ Copy to Clipboard">ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬</button>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<div class="actions">
					<span class="spacer"></span>
					<button id="closeExport" data-text-ko="ë‹«ê¸°" data-text-en="Close">ë‹«ê¸°</button>
				</div>
			</div>
		</div>
	</div>

	<script>
	(async function(){
		const modeEl = document.getElementById('mode');
		const statusEl = document.getElementById('status');
		const listEl = null;
		const fginfoEl = document.getElementById('fginfo');
		const valuePick = document.getElementById('valuePick');
		let lastWindows = [];
		const winTableBody = document.getElementById('winTableBody');
		let sortKey = 'process';
		let sortDir = 'asc'; // 'asc' | 'desc'
		const headerMap = {
			title: document.getElementById('th_title'),
			process: document.getElementById('th_process'),
			hwnd: document.getElementById('th_hwnd'),
			class: document.getElementById('th_class')
		};
		const arrowMap = {
			title: document.getElementById('arrow_title'),
			process: document.getElementById('arrow_process'),
			hwnd: document.getElementById('arrow_hwnd'),
			class: document.getElementById('arrow_class')
		};

		// =============================================
		// Key Image Settings (localStorage based)
		// =============================================
		const STORAGE_KEY_IMAGES = 'kv_key_images';
		const STORAGE_KEY_HIDE = 'kv_hide_key_text';

		// Common key labels for dropdown
		const COMMON_KEYS = [
			'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
			'0','1','2','3','4','5','6','7','8','9',
			'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
			'ESC','TAB','CAPS','LSHIFT','RSHIFT','LCTRL','RCTRL','LALT','RALT',
			'LCMD','RCMD','LOPT','ROPT','LWIN','RWIN','LSUPER','RSUPER',
			'SPACE','ENTER','BACKSPACE','DELETE','INSERT','HOME','END','PAGEUP','PAGEDOWN',
			'UP','DOWN','LEFT','RIGHT','FN',
			'NUM0','NUM1','NUM2','NUM3','NUM4','NUM5','NUM6','NUM7','NUM8','NUM9',
			'NUMLOCK','NUMENTER','NUMADD','NUMSUB','NUMMUL','NUMDIV','NUMDOT',
			'-','=','[',']','\\',';','\'',',','.','/','`'
		];

		function getKeyImages() {
			try { return JSON.parse(localStorage.getItem(STORAGE_KEY_IMAGES) || '{}'); } catch(e) { return {}; }
		}
		function setKeyImages(data) {
			localStorage.setItem(STORAGE_KEY_IMAGES, JSON.stringify(data));
		}
		function getHideKeyText() {
			try { return JSON.parse(localStorage.getItem(STORAGE_KEY_HIDE) || '{}'); } catch(e) { return {}; }
		}
		function setHideKeyText(data) {
			localStorage.setItem(STORAGE_KEY_HIDE, JSON.stringify(data));
		}

		function fileToBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file);
			});
		}

		// =============================================
		// Image Crop Functionality
		// =============================================
		const modalCrop = document.getElementById('modalCrop');
		const cropCanvas = document.getElementById('cropCanvas');
		const cropOverlay = document.getElementById('cropOverlay');
		const cropContainer = document.getElementById('cropContainer');
		const cropZoom = document.getElementById('cropZoom');
		const cropZoomValue = document.getElementById('cropZoomValue');
		const cropChipSizeEl = document.getElementById('cropChipSize');
		const cropApply = document.getElementById('cropApply');
		const cropCancel = document.getElementById('cropCancel');

		let cropImage = null;
		let cropState = { x: 0, y: 0, zoom: 1, dragging: false, startX: 0, startY: 0 };
		let cropCallback = null;
		let cropTargetKey = null;
		let cropChipW = 80;
		let cropChipH = 50;

		async function loadChipSizeFromOverlay() {
			try {
				const res = await fetch('/api/overlay-config');
				const cfg = await res.json();
				// Calculate chip size from overlay settings
				const fontPx = cfg.chip_font_px || 24;
				const padV = cfg.chip_pad_v || 10;
				const padH = cfg.chip_pad_h || 14;
				cropChipH = fontPx + (padV * 2);
				// Add extra width (1.5x) to accommodate longer keys like SPACE
				cropChipW = Math.max(60, Math.round((fontPx * 2 + (padH * 2)) * 1.5));
				cropChipSizeEl.textContent = `${cropChipW} x ${cropChipH} px`;
			} catch (e) {
				cropChipW = 100;
				cropChipH = 50;
				cropChipSizeEl.textContent = `${cropChipW} x ${cropChipH} px`;
			}
		}

		async function openCropModal(imageSrc, targetKey, callback) {
			cropCallback = callback;
			cropTargetKey = targetKey;
			cropState = { x: 0, y: 0, zoom: 1, dragging: false, startX: 0, startY: 0 };
			cropZoom.value = 1;
			cropZoomValue.textContent = '100%';
			
			// Load chip size from overlay settings
			await loadChipSizeFromOverlay();
			
			cropImage = new Image();
			cropImage.onload = () => {
				modalCrop.style.display = 'flex';
				requestAnimationFrame(renderCrop);
			};
			cropImage.src = imageSrc;
		}

		function closeCropModal() {
			modalCrop.style.display = 'none';
			cropImage = null;
			cropCallback = null;
		}

		function renderCrop() {
			if (!cropImage) return;
			
			const chipW = cropChipW;
			const chipH = cropChipH;
			const containerW = cropContainer.clientWidth;
			const containerH = 400;
			
			// Set canvas size
			cropCanvas.width = containerW;
			cropCanvas.height = containerH;
			cropOverlay.width = containerW;
			cropOverlay.height = containerH;
			cropOverlay.style.width = containerW + 'px';
			cropOverlay.style.height = containerH + 'px';
			
			const ctx = cropCanvas.getContext('2d');
			const ovCtx = cropOverlay.getContext('2d');
			
			// Clear
			ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, containerW, containerH);
			
			// Draw image with zoom and offset
			const imgW = cropImage.width * cropState.zoom;
			const imgH = cropImage.height * cropState.zoom;
			const imgX = (containerW - imgW) / 2 + cropState.x;
			const imgY = (containerH - imgH) / 2 + cropState.y;
			ctx.drawImage(cropImage, imgX, imgY, imgW, imgH);
			
			// Draw overlay (dark outside chip area)
			ovCtx.clearRect(0, 0, containerW, containerH);
			ovCtx.fillStyle = 'rgba(0, 0, 0, 0.6)';
			ovCtx.fillRect(0, 0, containerW, containerH);
			
			// Clear chip area (transparent hole)
			const chipX = (containerW - chipW) / 2;
			const chipY = (containerH - chipH) / 2;
			ovCtx.clearRect(chipX, chipY, chipW, chipH);
			
			// Draw chip border
			ovCtx.strokeStyle = '#4f8cff';
			ovCtx.lineWidth = 2;
			ovCtx.strokeRect(chipX, chipY, chipW, chipH);
			
			// Draw chip corners
			const cornerSize = 10;
			ovCtx.strokeStyle = '#fff';
			ovCtx.lineWidth = 3;
			// Top-left
			ovCtx.beginPath(); ovCtx.moveTo(chipX, chipY + cornerSize); ovCtx.lineTo(chipX, chipY); ovCtx.lineTo(chipX + cornerSize, chipY); ovCtx.stroke();
			// Top-right
			ovCtx.beginPath(); ovCtx.moveTo(chipX + chipW - cornerSize, chipY); ovCtx.lineTo(chipX + chipW, chipY); ovCtx.lineTo(chipX + chipW, chipY + cornerSize); ovCtx.stroke();
			// Bottom-left
			ovCtx.beginPath(); ovCtx.moveTo(chipX, chipY + chipH - cornerSize); ovCtx.lineTo(chipX, chipY + chipH); ovCtx.lineTo(chipX + cornerSize, chipY + chipH); ovCtx.stroke();
			// Bottom-right
			ovCtx.beginPath(); ovCtx.moveTo(chipX + chipW - cornerSize, chipY + chipH); ovCtx.lineTo(chipX + chipW, chipY + chipH); ovCtx.lineTo(chipX + chipW, chipY + chipH - cornerSize); ovCtx.stroke();
		}

		function getCroppedImage() {
			if (!cropImage) return null;
			
			const chipW = cropChipW;
			const chipH = cropChipH;
			const containerW = cropCanvas.width;
			const containerH = cropCanvas.height;
			
			// Calculate crop area in image coordinates
			const imgW = cropImage.width * cropState.zoom;
			const imgH = cropImage.height * cropState.zoom;
			const imgX = (containerW - imgW) / 2 + cropState.x;
			const imgY = (containerH - imgH) / 2 + cropState.y;
			
			const chipX = (containerW - chipW) / 2;
			const chipY = (containerH - chipH) / 2;
			
			// Convert chip coordinates to source image coordinates
			const srcX = (chipX - imgX) / cropState.zoom;
			const srcY = (chipY - imgY) / cropState.zoom;
			const srcW = chipW / cropState.zoom;
			const srcH = chipH / cropState.zoom;
			
			// Create output canvas
			const outCanvas = document.createElement('canvas');
			outCanvas.width = chipW;
			outCanvas.height = chipH;
			const outCtx = outCanvas.getContext('2d');
			
			outCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, chipW, chipH);
			
			// Convert to WebP with compression
			return outCanvas.toDataURL('image/webp', 0.85);
		}

		// Crop event handlers
		cropZoom.addEventListener('input', () => {
			cropState.zoom = parseFloat(cropZoom.value);
			cropZoomValue.textContent = Math.round(cropState.zoom * 100) + '%';
			renderCrop();
		});

		cropContainer.addEventListener('mousedown', (e) => {
			cropState.dragging = true;
			cropState.startX = e.clientX - cropState.x;
			cropState.startY = e.clientY - cropState.y;
			e.preventDefault();
		});

		cropContainer.addEventListener('mousemove', (e) => {
			if (!cropState.dragging) return;
			cropState.x = e.clientX - cropState.startX;
			cropState.y = e.clientY - cropState.startY;
			renderCrop();
		});

		cropContainer.addEventListener('mouseup', () => {
			cropState.dragging = false;
		});

		cropContainer.addEventListener('mouseleave', () => {
			cropState.dragging = false;
		});

		cropContainer.addEventListener('wheel', (e) => {
			e.preventDefault();
			const delta = e.deltaY > 0 ? -0.1 : 0.1;
			cropState.zoom = Math.max(0.5, Math.min(3, cropState.zoom + delta));
			cropZoom.value = cropState.zoom;
			cropZoomValue.textContent = Math.round(cropState.zoom * 100) + '%';
			renderCrop();
		}, { passive: false });

		cropApply.addEventListener('click', () => {
			const croppedData = getCroppedImage();
			if (croppedData && cropCallback) {
				cropCallback(croppedData, cropTargetKey);
			}
			closeCropModal();
		});

		cropCancel.addEventListener('click', closeCropModal);
		// =============================================
		// End Image Crop
		// =============================================

		// Key Image Modal Elements
		const modalKeyImage = document.getElementById('modalKeyImage');
		const closeKeyImage = document.getElementById('closeKeyImage');
		const kiDefaultImg = document.getElementById('ki_default_img');
		const kiDefaultClear = document.getElementById('ki_default_clear');
		const kiDefaultHide = document.getElementById('ki_default_hide');
		const kiDefaultPreview = document.getElementById('ki_default_preview');
		const kiDefaultPreviewImg = document.getElementById('ki_default_preview_img');
		const kiKeySelect = document.getElementById('ki_key_select');
		const kiAddCustom = document.getElementById('ki_add_custom');
		const kiKeyConfig = document.getElementById('ki_key_config');
		const kiSelectedKey = document.getElementById('ki_selected_key');
		const kiKeyImg = document.getElementById('ki_key_img');
		const kiKeyClear = document.getElementById('ki_key_clear');
		const kiKeyHide = document.getElementById('ki_key_hide');
		const kiKeyPreview = document.getElementById('ki_key_preview');
		const kiKeyPreviewImg = document.getElementById('ki_key_preview_img');
		const kiKeySave = document.getElementById('ki_key_save');
		const kiConfiguredList = document.getElementById('ki_configured_list');
		const kiClearAll = document.getElementById('ki_clear_all');
		const kiPreviewQueue = document.getElementById('ki_preview_queue');

		let currentEditKey = null;
		let pendingKeyImage = null;

		function openModalKeyImage() {
			modalKeyImage.style.display = 'flex';
			loadKeyImageSettings();
			populateKeySelect();
			updateConfiguredList();
			updateKIPreview();
		}
		function closeModalKeyImage() {
			modalKeyImage.style.display = 'none';
			currentEditKey = null;
			pendingKeyImage = null;
		}

		function loadKeyImageSettings() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			// Load default settings
			if (images['default']) {
				kiDefaultPreview.style.display = 'block';
				kiDefaultPreviewImg.src = images['default'];
			} else {
				kiDefaultPreview.style.display = 'none';
			}
			kiDefaultHide.checked = !!hides['default'];
		}

		function populateKeySelect() {
			const selectText = currentLanguage === 'ko' ? '-- í‚¤ ì„ íƒ --' : '-- Select Key --';
			kiKeySelect.innerHTML = `<option value="">${selectText}</option>`;
			COMMON_KEYS.forEach(k => {
				const opt = document.createElement('option');
				opt.value = k;
				opt.textContent = k;
				kiKeySelect.appendChild(opt);
			});
		}

		function updateConfiguredList() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			const keys = new Set([...Object.keys(images), ...Object.keys(hides)]);
			keys.delete('default'); // Don't show default in list
			
			if (keys.size === 0) {
				const emptyText = currentLanguage === 'ko' ? 'ì„¤ì •ëœ í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤' : 'No keys configured';
				kiConfiguredList.innerHTML = `<div class="help" style="text-align:center; padding:20px">${emptyText}</div>`;
				return;
			}
			
			let html = '';
			Array.from(keys).sort().forEach(key => {
				const hasImg = !!images[key];
				const hideText = !!hides[key];
				const imgIcon = hasImg ? 'ğŸ–¼ï¸' : '';
				const hideIcon = hideText ? 'ğŸ‘ï¸â€ğŸ—¨ï¸' : '';
				html += `<div style="display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px solid var(--border)">
					<span class="badge">${key}</span>
					<span style="font-size:12px">${imgIcon} ${hideIcon}</span>
					<span class="spacer"></span>
					<button onclick="editKeyImage('${key}')" style="padding:4px 8px; font-size:11px" data-text-ko="í¸ì§‘" data-text-en="Edit">í¸ì§‘</button>
					<button onclick="removeKeyImage('${key}')" class="danger" style="padding:4px 8px; font-size:11px" data-text-ko="ì‚­ì œ" data-text-en="Delete">ì‚­ì œ</button>
				</div>`;
			});
			kiConfiguredList.innerHTML = html;
		}

		// Expose functions globally for onclick handlers
		window.editKeyImage = function(key) {
			currentEditKey = key;
			kiSelectedKey.textContent = key;
			kiKeyConfig.style.display = 'block';
			
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			if (images[key]) {
				kiKeyPreview.style.display = 'block';
				kiKeyPreviewImg.src = images[key];
				pendingKeyImage = images[key];
			} else {
				kiKeyPreview.style.display = 'none';
				pendingKeyImage = null;
			}
			kiKeyHide.checked = !!hides[key];
			kiKeyImg.value = '';
		};

		window.removeKeyImage = function(key) {
			const images = getKeyImages();
			const hides = getHideKeyText();
			delete images[key];
			delete hides[key];
			setKeyImages(images);
			setHideKeyText(hides);
			updateConfiguredList();
			updateKIPreview();
			
			if (currentEditKey === key) {
				kiKeyConfig.style.display = 'none';
				currentEditKey = null;
			}
		};

		function updateKIPreview() {
			const images = getKeyImages();
			const hides = getHideKeyText();
			// Include longer keys like SPACE, ENTER for preview
			const sampleKeys = ['Q', 'W', 'SPACE', 'ENTER'];
			
			kiPreviewQueue.innerHTML = '';
			sampleKeys.forEach(k => {
				const chip = document.createElement('div');
				chip.className = 'chip';
				chip.style.cssText = 'background:var(--chip-bg, rgba(0,0,0,0.6)); color:var(--chip-fg, #fff); padding:10px 14px; border-radius:10px; font-size:24px; font-weight:700; min-width:44px; text-align:center; display:flex; align-items:center; justify-content:center; background-size:cover; background-position:center;';
				
				const img = images[k] || images['default'];
				const hideText = hides[k] !== undefined ? hides[k] : hides['default'];
				
				// Set image as background
				if (img) {
					chip.style.backgroundImage = `url(${img})`;
				}
				
				// Always add text to maintain size, use transparent color if hidden
				chip.textContent = k;
				if (hideText) {
					chip.style.color = 'transparent';
				}
				
				kiPreviewQueue.appendChild(chip);
			});
		}

		// Event Handlers
		closeKeyImage.addEventListener('click', closeModalKeyImage);

		kiDefaultImg.addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			
			// Check file size (max 5MB for upload, will be compressed after crop)
			if (file.size > 5 * 1024 * 1024) {
				alert(currentLanguage === 'ko' ? 'ì´ë¯¸ì§€ í¬ê¸°ê°€ 5MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤' : 'Image size exceeds 5MB');
				kiDefaultImg.value = '';
				return;
			}
			
			const base64 = await fileToBase64(file);
			// Open crop modal
			openCropModal(base64, 'default', (croppedData, targetKey) => {
				const images = getKeyImages();
				images[targetKey] = croppedData;
				setKeyImages(images);
				
				kiDefaultPreview.style.display = 'block';
				kiDefaultPreviewImg.src = croppedData;
				updateKIPreview();
			});
			kiDefaultImg.value = '';
		});

		kiDefaultClear.addEventListener('click', () => {
			const images = getKeyImages();
			delete images['default'];
			setKeyImages(images);
			kiDefaultPreview.style.display = 'none';
			kiDefaultImg.value = '';
			updateKIPreview();
		});

		kiDefaultHide.addEventListener('change', () => {
			const hides = getHideKeyText();
			hides['default'] = kiDefaultHide.checked;
			setHideKeyText(hides);
			updateKIPreview();
		});

		kiKeySelect.addEventListener('change', () => {
			const key = kiKeySelect.value;
			if (!key) {
				kiKeyConfig.style.display = 'none';
				currentEditKey = null;
				return;
			}
			window.editKeyImage(key);
		});

		kiAddCustom.addEventListener('click', () => {
			const promptText = currentLanguage === 'ko' ? 'í‚¤ ì´ë¦„ ì…ë ¥ (ì˜ˆ: SPACE, LCMD):' : 'Enter key name (e.g., SPACE, LCMD):';
			const key = prompt(promptText);
			if (key && key.trim()) {
				window.editKeyImage(key.trim().toUpperCase());
				kiKeySelect.value = '';
			}
		});

		kiKeyImg.addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			
			// Check file size (max 5MB for upload, will be compressed after crop)
			if (file.size > 5 * 1024 * 1024) {
				alert(currentLanguage === 'ko' ? 'ì´ë¯¸ì§€ í¬ê¸°ê°€ 5MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤' : 'Image size exceeds 5MB');
				kiKeyImg.value = '';
				return;
			}
			
			const base64 = await fileToBase64(file);
			// Open crop modal
			openCropModal(base64, currentEditKey, (croppedData, targetKey) => {
				pendingKeyImage = croppedData;
				kiKeyPreview.style.display = 'block';
				kiKeyPreviewImg.src = croppedData;
			});
			kiKeyImg.value = '';
		});

		kiKeyClear.addEventListener('click', () => {
			pendingKeyImage = null;
			kiKeyPreview.style.display = 'none';
			kiKeyImg.value = '';
		});

		kiKeySave.addEventListener('click', () => {
			if (!currentEditKey) return;
			
			const images = getKeyImages();
			const hides = getHideKeyText();
			
			if (pendingKeyImage) {
				images[currentEditKey] = pendingKeyImage;
			} else {
				delete images[currentEditKey];
			}
			
			if (kiKeyHide.checked) {
				hides[currentEditKey] = true;
			} else {
				delete hides[currentEditKey];
			}
			
			setKeyImages(images);
			setHideKeyText(hides);
			
			updateConfiguredList();
			updateKIPreview();
			
			// Reset form
			kiKeyConfig.style.display = 'none';
			kiKeySelect.value = '';
			currentEditKey = null;
			pendingKeyImage = null;
		});

		kiClearAll.addEventListener('click', () => {
			const confirmText = currentLanguage === 'ko' ? 'ëª¨ë“  í‚¤ ì´ë¯¸ì§€ ì„¤ì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?' : 'Clear all key image settings?';
			if (confirm(confirmText)) {
				localStorage.removeItem(STORAGE_KEY_IMAGES);
				localStorage.removeItem(STORAGE_KEY_HIDE);
				loadKeyImageSettings();
				updateConfiguredList();
				updateKIPreview();
				kiKeyConfig.style.display = 'none';
			}
		});
		// =============================================
		// End Key Image Settings
		// =============================================

		function safeAddEventListener(element, event, handler) {
			if (element && typeof element.addEventListener === 'function') {
				element.addEventListener(event, handler);
			}
		}

		const modalAll = document.getElementById('modalAll');
		const cancelAll = document.getElementById('cancelAll');
		const saveAll = document.getElementById('saveAll');
		let confirmTimer = null;

		const modalOverlay = document.getElementById('modalOverlay');
		const openOverlayCfg = document.getElementById('openOverlayCfg');
		const closeOverlay = document.getElementById('closeOverlay');
		const saveOverlay = document.getElementById('saveOverlay');

		const ov_fade_in = document.getElementById('ov_fade_in');
		const ov_fade_out = document.getElementById('ov_fade_out');
		const ov_chip_bg = document.getElementById('ov_chip_bg');
		const ov_chip_fg = document.getElementById('ov_chip_fg');
		const ov_bg_pickBtn = document.getElementById('ov_bg_pick');
		const ov_bg_picker = document.getElementById('ov_bg_picker');
		const ov_bg_trans = document.getElementById('ov_bg_trans');
		const ov_chip_bg_pickBtn = document.getElementById('ov_chip_bg_pick');
		const ov_chip_bg_picker = document.getElementById('ov_chip_bg_picker');
		const ov_chip_fg_pickBtn = document.getElementById('ov_chip_fg_pick');
		const ov_chip_fg_picker = document.getElementById('ov_chip_fg_picker');
		const ov_bg = document.getElementById('ov_bg');
		const ov_gap = document.getElementById('ov_gap');
		const ov_pad_v = document.getElementById('ov_pad_v');
		const ov_pad_h = document.getElementById('ov_pad_h');
		const ov_radius = document.getElementById('ov_radius');
		const ov_font_px = document.getElementById('ov_font_px');
		const ov_font_w = document.getElementById('ov_font_w');
		const ov_cols = document.getElementById('ov_cols');
		const ov_rows = document.getElementById('ov_rows');
		const ov_align = document.getElementById('ov_align');
		const ov_direction = document.getElementById('ov_direction');


		// ========== Unified Style Modal elements ==========
		const modalUnifiedStyle = document.getElementById('modalUnifiedStyle');
		const openUnifiedStyle = document.getElementById('openUnifiedStyle');
		const usStyleSave = document.getElementById('usStyleSave');
		const usStyleReset = document.getElementById('usStyleReset');
		const usStyleClose = document.getElementById('usStyleClose');
		
		// Tab buttons
		const usTabBg = document.getElementById('usTabBg');
		const usTabChip = document.getElementById('usTabChip');
		const usTabFont = document.getElementById('usTabFont');
		
		// Tab panels
		const usPanelBg = document.getElementById('usPanelBg');
		const usPanelChip = document.getElementById('usPanelChip');
		const usPanelFont = document.getElementById('usPanelFont');
		
		// Background tab elements
		const us_bg_transparent = document.getElementById('us_bg_transparent');
		const us_bg_mode = document.getElementById('us_bg_mode');
		const us_bg_color = document.getElementById('us_bg_color');
		const usBgColorSection = document.getElementById('usBgColorSection');
		const usBgSolid = document.getElementById('usBgSolid');
		const usBgGradient = document.getElementById('usBgGradient');
		const usBgImage = document.getElementById('usBgImage');
		
		// Chip tab elements
		const us_chip_gap = document.getElementById('us_chip_gap');
		const us_chip_pad_v = document.getElementById('us_chip_pad_v');
		const us_chip_pad_h = document.getElementById('us_chip_pad_h');
		const us_chip_radius = document.getElementById('us_chip_radius');
		const usGroupList = document.getElementById('usGroupList');
		const usAddGroup = document.getElementById('usAddGroup');
		const usNoGroups = document.getElementById('usNoGroups');
		const usGroupEditor = document.getElementById('usGroupEditor');
		
		// Group editor elements
		const usGroupEditId = document.getElementById('usGroupEditId');
		const usGroupName = document.getElementById('usGroupName');
		const usGroupType = document.getElementById('usGroupType');
		const usGroupKeysSection = document.getElementById('usGroupKeysSection');
		const usRecordKeys = document.getElementById('usRecordKeys');
		const usRecordedKeys = document.getElementById('usRecordedKeys');
		const usGroupBgMode = document.getElementById('usGroupBgMode');
		const usGroupBgSolid = document.getElementById('usGroupBgSolid');
		const usGroupBgGrad = document.getElementById('usGroupBgGrad');
		const usGroupBgImage = document.getElementById('usGroupBgImage');
		const usGroupSave = document.getElementById('usGroupSave');
		const usGroupCancel = document.getElementById('usGroupCancel');
		
		// Font tab elements
		const us_font_family = document.getElementById('us_font_family');
		const us_font_url = document.getElementById('us_font_url');
		const usFontUrlSection = document.getElementById('usFontUrlSection');
		const us_font_size = document.getElementById('us_font_size');
		const us_font_weight = document.getElementById('us_font_weight');
		const us_font_color = document.getElementById('us_font_color');
		const us_font_shadow = document.getElementById('us_font_shadow');
		
		// Preview
		const us_preview = document.getElementById('us_preview');
		const us_preview_queue = document.getElementById('us_preview_queue');
		
		// Style groups data storage
		let styleGroups = [];
		let usRecording = false;
		let usRecordedKeysList = [];

		const debugMode = document.getElementById('debugMode');
		const debugValue = document.getElementById('debugValue');
		const debugStatus = document.getElementById('debugStatus');

		let savedValue = '';
		let currentLanguage = 'ko'; // ê¸°ë³¸ê°’ì„ í•œêµ­ì–´ë¡œ ì„¤ì •
		let currentStatus = ''; // í˜„ì¬ ì‘ë™ ìƒíƒœ ì €ì¥

		async function loadLanguageSettings() {
			try {
				const response = await fetch('/api/launcher-language');
				if (response.ok) {
					const data = await response.json();
					currentLanguage = data.language || 'ko';
					console.log('âœ“ Language loaded:', currentLanguage);
					updateUILanguage();
				} else {
					console.warn('Failed to load language, using default: ko');
					currentLanguage = 'ko';
					updateUILanguage();
				}
			} catch (e) {
				console.error('Error loading language:', e);
				currentLanguage = 'ko'; // ì—ëŸ¬ ì‹œì—ë„ í•œêµ­ì–´ë¥¼ ê¸°ë³¸ìœ¼ë¡œ
				updateUILanguage();
			}
		}

		function updateUILanguage() {
			const lang = currentLanguage;
			
			document.querySelectorAll('[data-text-ko], [data-text-en]').forEach(element => {
				const koText = element.getAttribute('data-text-ko');
				const enText = element.getAttribute('data-text-en');
				
				if (lang === 'ko' && koText) {
					element.textContent = koText;
				} else if (lang === 'en' && enText) {
					element.textContent = enText;
				}
			});

			document.querySelectorAll('[data-title-ko], [data-title-en]').forEach(element => {
				const koTitle = element.getAttribute('data-title-ko');
				const enTitle = element.getAttribute('data-title-en');
				
				if (lang === 'ko' && koTitle) {
					element.title = koTitle;
				} else if (lang === 'en' && enTitle) {
					element.title = enTitle;
				}
			});

			// Update placeholders
			document.querySelectorAll('[data-placeholder-ko], [data-placeholder-en]').forEach(element => {
				const koPlaceholder = element.getAttribute('data-placeholder-ko');
				const enPlaceholder = element.getAttribute('data-placeholder-en');
				
				if (lang === 'ko' && koPlaceholder) {
					element.placeholder = koPlaceholder;
				} else if (lang === 'en' && enPlaceholder) {
					element.placeholder = enPlaceholder;
				}
			});

			document.querySelectorAll('select option[data-text-ko], select option[data-text-en]').forEach(option => {
				const koText = option.getAttribute('data-text-ko');
				const enText = option.getAttribute('data-text-en');
				
				if (lang === 'ko' && koText) {
					option.textContent = koText;
				} else if (lang === 'en' && enText) {
					option.textContent = enText;
				}
			});

			if (lang === 'ko') {
				document.title = 'Key Queue Viewer ì„¤ì •';
			} else {
				document.title = 'Key Queue Viewer Settings';
			}

			if (statusEl.textContent) {
				if (statusEl.textContent === 'ì €ì¥ ì¤‘...' || statusEl.textContent === 'Saving...') {
					statusEl.textContent = lang === 'ko' ? 'ì €ì¥ ì¤‘...' : 'Saving...';
				} else if (statusEl.textContent === 'ì ìš©ë¨' || statusEl.textContent === 'Applied') {
					statusEl.textContent = lang === 'ko' ? 'ì ìš©ë¨' : 'Applied';
				} else if (statusEl.textContent === 'ì˜¤ë¥˜' || statusEl.textContent === 'Error') {
					statusEl.textContent = lang === 'ko' ? 'ì˜¤ë¥˜' : 'Error';
				}
			}

			if (fginfoEl.textContent && fginfoEl.textContent.includes('ì½ê¸° ì‹¤íŒ¨')) {
				fginfoEl.textContent = lang === 'ko' ? 'ì½ê¸° ì‹¤íŒ¨' : 'Read Failed';
			}
			if (currentStatus) {
				if (currentStatus === 'ë¹„í™œì„±í™”' || currentStatus === 'Disabled') {
					currentStatus = lang === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (currentStatus === 'ëª¨ë“  ì°½ í™œì„±í™”' || currentStatus === 'All Windows Active') {
					currentStatus = lang === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (currentStatus === 'í™œì„±í™”' || currentStatus === 'Active') {
					currentStatus = lang === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else if (currentStatus === 'ì„¤ì • ì•ˆë¨' || currentStatus === 'Not Configured') {
					currentStatus = lang === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
			}
			
			updateDebugInfo();
		}

		function updateDebugInfo() {
			debugMode.textContent = modeEl.value || '-';
			debugValue.textContent = savedValue || '-';
			debugStatus.textContent = currentStatus || '-';
		}

		function openModalAll(){
			modalAll.style.display = 'flex';
			saveAll.disabled = true;
			if (confirmTimer) clearTimeout(confirmTimer);
			confirmTimer = setTimeout(()=> { saveAll.disabled = false; }, 2000);
		}
		function closeModalAll(){
			modalAll.style.display = 'none';
			if (confirmTimer) clearTimeout(confirmTimer);
		}

		function openModalOverlay(){ modalOverlay.style.display = 'flex'; }
		function closeModalOverlay(){ modalOverlay.style.display = 'none'; }

		
		// ========== Unified Style Modal Functions ==========
		function openModalUnifiedStyle() {
			modalUnifiedStyle.style.display = 'flex';
			loadUnifiedStyleConfig();
			switchUnifiedTab('bg');
			renderBgGradStops();
			updateUnifiedPreview();
		}
		
		function closeModalUnifiedStyle() {
			modalUnifiedStyle.style.display = 'none';
			usGroupEditor.style.display = 'none';
		}
		
		function switchUnifiedTab(tab) {
			// Update tab button states
			[usTabBg, usTabChip, usTabFont].forEach(t => t && t.classList.remove('active'));
			
			// Hide all panels
			if (usPanelBg) usPanelBg.style.display = 'none';
			if (usPanelChip) usPanelChip.style.display = 'none';
			if (usPanelFont) usPanelFont.style.display = 'none';
			
			// Show selected panel
			switch(tab) {
				case 'bg':
					if (usTabBg) usTabBg.classList.add('active');
					if (usPanelBg) usPanelBg.style.display = 'block';
					break;
				case 'chip':
					if (usTabChip) usTabChip.classList.add('active');
					if (usPanelChip) usPanelChip.style.display = 'block';
					renderStyleGroupsList();
					break;
				case 'font':
					if (usTabFont) usTabFont.classList.add('active');
					if (usPanelFont) usPanelFont.style.display = 'block';
					renderStyleGroupsList();
					break;
			}
		}
		
		// Tab click handlers
		if (usTabBg) usTabBg.addEventListener('click', () => switchUnifiedTab('bg'));
		if (usTabChip) usTabChip.addEventListener('click', () => switchUnifiedTab('chip'));
		if (usTabFont) usTabFont.addEventListener('click', () => switchUnifiedTab('font'));
		
		// Background transparency toggle
		if (us_bg_transparent) {
			us_bg_transparent.addEventListener('change', () => {
				if (usBgColorSection) {
					usBgColorSection.style.display = us_bg_transparent.checked ? 'none' : 'block';
				}
				updateUnifiedPreview();
			});
		}
		
		// Background mode toggle
		if (us_bg_mode) {
			us_bg_mode.addEventListener('change', () => {
				const mode = us_bg_mode.value;
				if (usBgSolid) usBgSolid.style.display = mode === 'solid' ? 'block' : 'none';
				if (usBgGradient) usBgGradient.style.display = mode === 'gradient' ? 'block' : 'none';
				if (usBgImage) usBgImage.style.display = mode === 'image' ? 'block' : 'none';
				if (mode === 'gradient') renderBgGradStops();
				updateUnifiedPreview();
			});
		}
		
		// Font family toggle for custom URL
		if (us_font_family) {
			us_font_family.addEventListener('change', () => {
				if (usFontUrlSection) {
					usFontUrlSection.style.display = us_font_family.value === 'custom' ? 'block' : 'none';
				}
				updateUnifiedPreview();
			});
		}
		
		// Group type toggle
		if (usGroupType) {
			usGroupType.addEventListener('change', () => {
				if (usGroupKeysSection) {
					usGroupKeysSection.style.display = usGroupType.value === 'all' ? 'none' : 'block';
				}
			});
		}
		
		// Group background mode toggle
		if (usGroupBgMode) {
			usGroupBgMode.addEventListener('change', () => {
				const mode = usGroupBgMode.value;
				if (usGroupBgSolid) usGroupBgSolid.style.display = mode === 'solid' ? 'block' : 'none';
				if (usGroupBgGrad) usGroupBgGrad.style.display = mode === 'gradient' ? 'block' : 'none';
				if (usGroupBgImage) usGroupBgImage.style.display = mode === 'image' ? 'block' : 'none';
			});
		}
		
		// Add new group button
		if (usAddGroup) {
			usAddGroup.addEventListener('click', () => {
				usGroupEditId.value = '';
				usGroupName.value = '';
				usGroupType.value = 'individual';
				usRecordedKeysList = [];
				usRecordedKeys.textContent = '';
				usGroupBgMode.value = 'solid';
				usGroupImageData = null;
				usGroupTextOpacity = 1;
				resetGroupGrad();
				if (usGroupImagePreview) usGroupImagePreview.style.display = 'none';
				if (usGroupBgSolid) usGroupBgSolid.style.display = 'block';
				if (usGroupBgGrad) usGroupBgGrad.style.display = 'none';
				if (usGroupBgImage) usGroupBgImage.style.display = 'none';
				usGroupEditor.style.display = 'block';
				updateMouseButtonStates();
			});
		}
		
		// Group save button
		if (usGroupSave) {
			usGroupSave.addEventListener('click', () => {
				const name = usGroupName.value.trim() || 'Unnamed Group';
				const type = usGroupType.value;
				const keys = type === 'all' ? ['*'] : usRecordedKeysList;
				const bgMode = usGroupBgMode.value;
				
				const group = {
					id: usGroupEditId.value || Date.now().toString(),
					name,
					type,
					keys,
					bgMode,
					bgColor: document.getElementById('usGroupBgColor')?.value || '#000000',
					gradStops: groupGradEditor.getStops(),
					gradAngle: groupGradEditor.getAngle(),
					image: usGroupImageData,
					textOpacity: usGroupTextOpacity
				};
				
				// Find and update or add
				const existingIdx = styleGroups.findIndex(g => g.id === group.id);
				if (existingIdx >= 0) {
					styleGroups[existingIdx] = group;
				} else {
					styleGroups.push(group);
				}
				
				// Save to localStorage immediately
				localStorage.setItem('keyviewer_style_groups', JSON.stringify(styleGroups));
				
				usGroupEditor.style.display = 'none';
				renderStyleGroupsList();
				updateUnifiedPreview();
			});
		}
		
		// Group cancel button
		if (usGroupCancel) {
			usGroupCancel.addEventListener('click', () => {
				usGroupEditor.style.display = 'none';
			});
		}
		
		// Key recording for groups (unified modal)
		function handleUnifiedKeydown(event) {
			if (!usRecording) return;
			event.preventDefault();
			const key = event.key.toUpperCase();
			// Normalize special keys
			let normalizedKey = key;
			if (event.code === 'ShiftLeft') normalizedKey = 'LSHIFT';
			else if (event.code === 'ShiftRight') normalizedKey = 'RSHIFT';
			else if (event.code === 'ControlLeft') normalizedKey = 'LCTRL';
			else if (event.code === 'ControlRight') normalizedKey = 'RCTRL';
			else if (event.code === 'AltLeft') normalizedKey = 'LALT';
			else if (event.code === 'AltRight') normalizedKey = 'RALT';
			else if (key === ' ') normalizedKey = 'SPACE';
			else if (key === 'ESCAPE') normalizedKey = 'ESC';
			
			if (!usRecordedKeysList.includes(normalizedKey)) {
				usRecordedKeysList.push(normalizedKey);
				if (usRecordedKeys) usRecordedKeys.textContent = usRecordedKeysList.join(', ');
				
				// For individual key type, stop recording after first key
				if (usGroupType && usGroupType.value === 'individual') {
					stopUnifiedRecording();
				}
			}
		}
		
		function stopUnifiedRecording() {
			usRecording = false;
			if (usRecordKeys) {
				usRecordKeys.textContent = currentLanguage === 'ko' ? 'ğŸ¤ ë…¹í™”' : 'ğŸ¤ Record';
				usRecordKeys.classList.remove('primary');
			}
			document.removeEventListener('keydown', handleUnifiedKeydown);
		}
		
		if (usRecordKeys) {
			usRecordKeys.addEventListener('click', () => {
				if (usRecording) {
					// Stop recording
					stopUnifiedRecording();
				} else {
					// Start recording
					usRecording = true;
					usRecordedKeysList = [];
					if (usRecordedKeys) usRecordedKeys.textContent = '';
					usRecordKeys.textContent = currentLanguage === 'ko' ? 'â¹ï¸ ì¤‘ì§€' : 'â¹ï¸ Stop';
					usRecordKeys.classList.add('primary');
					document.addEventListener('keydown', handleUnifiedKeydown);
				}
			});
		}
		
		// Toggle mouse button in recorded keys
		function toggleMouseButton(btn) {
			const idx = usRecordedKeysList.indexOf(btn);
			if (idx >= 0) {
				// Remove if exists
				usRecordedKeysList.splice(idx, 1);
			} else {
				// Add if not exists
				usRecordedKeysList.push(btn);
			}
			if (usRecordedKeys) usRecordedKeys.textContent = usRecordedKeysList.join(', ');
			updateMouseButtonStates();
		}
		window.toggleMouseButton = toggleMouseButton;
		
		// Update mouse button visual states
		function updateMouseButtonStates() {
			const mouseButtons = {
				'LMB': document.getElementById('usMouseLMB'),
				'RMB': document.getElementById('usMouseRMB'),
				'MMB': document.getElementById('usMouseMMB'),
				'MOUSE4': document.getElementById('usMouseM4'),
				'MOUSE5': document.getElementById('usMouseM5')
			};
			for (const [key, btn] of Object.entries(mouseButtons)) {
				if (btn) {
					if (usRecordedKeysList.includes(key)) {
						btn.classList.add('selected');
					} else {
						btn.classList.remove('selected');
					}
				}
			}
		}
		
		
		// ========== Image Upload for Unified Style Modal ==========
		const usBgImageDrop = document.getElementById('usBgImageDrop');
		const usBgImageFile = document.getElementById('usBgImageFile');
		const usBgImagePreview = document.getElementById('usBgImagePreview');
		const usBgImagePreviewImg = document.getElementById('usBgImagePreviewImg');
		const usBgImageClear = document.getElementById('usBgImageClear');
		const usGroupImageDrop = document.getElementById('usGroupImageDrop');
		const usGroupImageFile = document.getElementById('usGroupImageFile');
		const usGroupImagePreview = document.getElementById('usGroupImagePreview');
		
		let usBgImageData = null;
		let usGroupImageData = null;
		let usGroupTextOpacity = 1;
		
		// Background image upload
		if (usBgImageDrop && usBgImageFile) {
			usBgImageDrop.addEventListener('click', () => usBgImageFile.click());
			usBgImageDrop.addEventListener('dragover', (e) => { e.preventDefault(); usBgImageDrop.classList.add('dragover'); });
			usBgImageDrop.addEventListener('dragleave', () => usBgImageDrop.classList.remove('dragover'));
			usBgImageDrop.addEventListener('drop', (e) => {
				e.preventDefault();
				usBgImageDrop.classList.remove('dragover');
				const file = e.dataTransfer.files[0];
				if (file && file.type.startsWith('image/')) handleBgImageFile(file);
			});
			usBgImageFile.addEventListener('change', (e) => {
				const file = e.target.files[0];
				if (file) {
					handleBgImageFile(file);
					e.target.value = ''; // Reset to allow same file selection
				}
			});
		}
		
		function handleBgImageFile(file) {
			const reader = new FileReader();
			reader.onload = (e) => {
				const imageSrc = e.target.result;
				// Open image editor
				openImageEditor(imageSrc, 'wide', (result) => {
					usBgImageData = result.image;
					if (usBgImagePreviewImg) usBgImagePreviewImg.src = usBgImageData;
					if (usBgImagePreview) usBgImagePreview.style.display = 'flex';
					updateUnifiedPreview();
				});
			};
			reader.readAsDataURL(file);
		}
		
		if (usBgImageClear) {
			usBgImageClear.addEventListener('click', () => {
				usBgImageData = null;
				if (usBgImagePreview) usBgImagePreview.style.display = 'none';
				updateUnifiedPreview();
			});
		}
		
		// Group image upload
		if (usGroupImageDrop && usGroupImageFile) {
			usGroupImageDrop.addEventListener('click', () => usGroupImageFile.click());
			usGroupImageDrop.addEventListener('dragover', (e) => { e.preventDefault(); usGroupImageDrop.classList.add('dragover'); });
			usGroupImageDrop.addEventListener('dragleave', () => usGroupImageDrop.classList.remove('dragover'));
			usGroupImageDrop.addEventListener('drop', (e) => {
				e.preventDefault();
				usGroupImageDrop.classList.remove('dragover');
				const file = e.dataTransfer.files[0];
				if (file && file.type.startsWith('image/')) handleGroupImageFile(file);
			});
			usGroupImageFile.addEventListener('change', (e) => {
				const file = e.target.files[0];
				if (file) {
					handleGroupImageFile(file);
					e.target.value = ''; // Reset to allow same file selection
				}
			});
		}
		
		function handleGroupImageFile(file) {
			const reader = new FileReader();
			reader.onload = (e) => {
				const imageSrc = e.target.result;
				openImageEditor(imageSrc, 'wide', (result) => {
					usGroupImageData = result.image;
					usGroupTextOpacity = result.textOpacity;
					if (usGroupImagePreview) {
						usGroupImagePreview.src = usGroupImageData;
						usGroupImagePreview.style.display = 'block';
					}
				});
			};
			reader.readAsDataURL(file);
		}
		
		// Render style groups list
		function renderStyleGroupsList() {
			if (!usGroupList) return;
			
			const usGroupFontList = document.getElementById('usGroupFontList');
			
			if (styleGroups.length === 0) {
				usGroupList.innerHTML = '';
				if (usNoGroups) usNoGroups.style.display = 'block';
				// Show empty message in font tab
				if (usGroupFontList) {
					usGroupFontList.innerHTML = `<div class="help" style="text-align:center; padding:16px; color:var(--muted)" data-text-ko="ì¹© íƒ­ì—ì„œ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”" data-text-en="Add style groups in Chip tab first">${currentLanguage === 'ko' ? 'ì¹© íƒ­ì—ì„œ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”' : 'Add style groups in Chip tab first'}</div>`;
				}
				return;
			}
			
			if (usNoGroups) usNoGroups.style.display = 'none';
			
			usGroupList.innerHTML = styleGroups.map(g => {
				let previewStyle = '';
				if (g.bgMode === 'image' && g.image) {
					previewStyle = `background-image:url(${g.image});background-size:cover;background-position:center`;
				} else if (g.bgMode === 'gradient') {
					if (g.gradStops && g.gradStops.length >= 2) {
						const sorted = [...g.gradStops].sort((a, b) => a.position - b.position);
						const stops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
						previewStyle = `background:linear-gradient(${g.gradAngle || 180}deg, ${stops})`;
					} else {
						previewStyle = `background:linear-gradient(180deg, ${g.gradColor1 || '#000'}, ${g.gradColor2 || '#333'})`;
					}
				} else {
					previewStyle = `background:${g.bgColor || '#000000'}`;
				}
				return `
				<div class="key-img-item" data-id="${g.id}">
					<div style="width:40px;height:40px;${previewStyle};border-radius:6px"></div>
					<div class="keys">
						<span style="font-weight:600">${g.name}</span>
						<span style="opacity:0.6;font-size:11px">${g.type === 'all' ? (currentLanguage === 'ko' ? 'ëª¨ë“  í‚¤' : 'All Keys') : g.keys.slice(0, 5).join(', ') + (g.keys.length > 5 ? '...' : '')}</span>
					</div>
					<div class="key-img-actions">
						<button onclick="editStyleGroup('${g.id}')">${currentLanguage === 'ko' ? 'ìˆ˜ì •' : 'Edit'}</button>
						<button class="danger" onclick="deleteStyleGroup('${g.id}')">${currentLanguage === 'ko' ? 'ì‚­ì œ' : 'Delete'}</button>
					</div>
				</div>`;
			}).join('');
			
			// Render font override list in Font tab
			if (usGroupFontList) {
				usGroupFontList.innerHTML = styleGroups.map(g => {
					const fontFamily = g.fontFamily || (currentLanguage === 'ko' ? 'ê¸°ë³¸ê°’' : 'Default');
					const fontSize = g.fontSize || '-';
					const fontWeight = g.fontWeight || '-';
					const fontColor = g.fontColor || '#ffffff';
					return `
					<div class="key-img-item" data-id="${g.id}" style="padding:10px 12px">
						<div style="width:36px;height:36px;background:${fontColor};border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:${isLightColor(fontColor) ? '#000' : '#fff'}">A</div>
						<div class="keys" style="flex:1">
							<span style="font-weight:600">${g.name}</span>
							<span style="opacity:0.6;font-size:11px">${fontFamily} / ${fontSize}px / ${fontWeight}</span>
						</div>
						<div class="key-img-actions">
							<button onclick="editGroupFont('${g.id}')">${currentLanguage === 'ko' ? 'í°íŠ¸ ì„¤ì •' : 'Font Settings'}</button>
						</div>
					</div>`;
				}).join('');
			}
		}
		
		// isLightColor is now in utils.js
		
		// Group Font Editor elements
		const usGroupFontEditor = document.getElementById('usGroupFontEditor');
		const usGroupFontEditId = document.getElementById('usGroupFontEditId');
		const usGroupFontEditTitle = document.getElementById('usGroupFontEditTitle');
		const usGroupFontFamily = document.getElementById('usGroupFontFamily');
		const usGroupFontSize = document.getElementById('usGroupFontSize');
		const usGroupFontWeight = document.getElementById('usGroupFontWeight');
		const usGroupFontColor = document.getElementById('usGroupFontColor');
		const usGroupFontColorText = document.getElementById('usGroupFontColorText');
		const usGroupFontSave = document.getElementById('usGroupFontSave');
		const usGroupFontCancel = document.getElementById('usGroupFontCancel');
		
		// Sync color picker and text input
		if (usGroupFontColor && usGroupFontColorText) {
			usGroupFontColor.addEventListener('input', () => {
				usGroupFontColorText.value = usGroupFontColor.value;
			});
			usGroupFontColorText.addEventListener('input', () => {
				if (/^#[0-9A-Fa-f]{6}$/.test(usGroupFontColorText.value)) {
					usGroupFontColor.value = usGroupFontColorText.value;
				}
			});
		}
		
		// Edit group font settings
		window.editGroupFont = function(id) {
			const group = styleGroups.find(g => g.id === id);
			if (!group) return;
			
			usGroupFontEditId.value = id;
			usGroupFontEditTitle.textContent = `${currentLanguage === 'ko' ? 'í°íŠ¸ ì„¤ì •:' : 'Font Settings:'} ${group.name}`;
			usGroupFontFamily.value = group.fontFamily || '';
			usGroupFontSize.value = group.fontSize || '';
			usGroupFontWeight.value = group.fontWeight || '';
			usGroupFontColor.value = group.fontColor || '#ffffff';
			usGroupFontColorText.value = group.fontColor || '#ffffff';
			
			usGroupFontEditor.style.display = 'block';
		};
		
		// Save group font
		if (usGroupFontSave) {
			usGroupFontSave.addEventListener('click', () => {
				const id = usGroupFontEditId.value;
				const group = styleGroups.find(g => g.id === id);
				if (!group) return;
				
				group.fontFamily = usGroupFontFamily.value || null;
				group.fontSize = usGroupFontSize.value ? parseInt(usGroupFontSize.value) : null;
				group.fontWeight = usGroupFontWeight.value ? parseInt(usGroupFontWeight.value) : null;
				group.fontColor = usGroupFontColorText.value || null;
				
				usGroupFontEditor.style.display = 'none';
				renderStyleGroupsList();
				updateUnifiedPreview();
			});
		}
		
		// Cancel group font edit
		if (usGroupFontCancel) {
			usGroupFontCancel.addEventListener('click', () => {
				usGroupFontEditor.style.display = 'none';
			});
		}
		
		// Edit style group
		window.editStyleGroup = function(id) {
			const group = styleGroups.find(g => g.id === id);
			if (!group) return;
			
			usGroupEditId.value = group.id;
			usGroupName.value = group.name;
			usGroupType.value = group.type;
			usRecordedKeysList = group.type === 'all' ? [] : [...group.keys];
			usRecordedKeys.textContent = usRecordedKeysList.join(', ');
			usGroupBgMode.value = group.bgMode || 'solid';
			
			// Set colors
			const bgColorEl = document.getElementById('usGroupBgColor');
			if (bgColorEl) bgColorEl.value = group.bgColor || '#000000';
			const bgColorPicker = document.getElementById('usGroupBgColor_picker');
			if (bgColorPicker) bgColorPicker.value = group.bgColor || '#000000';
			
			// Load gradient data using GradientEditor
			let gradStops = group.gradStops;
			if (!gradStops || gradStops.length < 2) {
				// Legacy support for gradColor1/gradColor2
				gradStops = [
					{ color: group.gradColor1 || '#000000', position: 0 },
					{ color: group.gradColor2 || '#333333', position: 100 }
				];
			}
			groupGradEditor.setData(gradStops, group.gradAngle || 180);
			
			// Load image data
			usGroupImageData = group.image || null;
			usGroupTextOpacity = group.textOpacity !== undefined ? group.textOpacity : 1;
			if (usGroupImagePreview) {
				if (usGroupImageData) {
					usGroupImagePreview.src = usGroupImageData;
					usGroupImagePreview.style.display = 'block';
				} else {
					usGroupImagePreview.style.display = 'none';
				}
			}
			
			// Toggle sections
			if (usGroupBgSolid) usGroupBgSolid.style.display = group.bgMode === 'solid' ? 'block' : 'none';
			if (usGroupBgGrad) usGroupBgGrad.style.display = group.bgMode === 'gradient' ? 'block' : 'none';
			if (usGroupBgImage) usGroupBgImage.style.display = group.bgMode === 'image' ? 'block' : 'none';
			if (usGroupKeysSection) usGroupKeysSection.style.display = group.type === 'all' ? 'none' : 'block';
			
			usGroupEditor.style.display = 'block';
			updateMouseButtonStates();
		};
		
		// Delete style group
		window.deleteStyleGroup = function(id) {
			const confirmMsg = currentLanguage === 'ko' ? 'ì´ ìŠ¤íƒ€ì¼ ê·¸ë£¹ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?' : 'Delete this style group?';
			if (confirm(confirmMsg)) {
				styleGroups = styleGroups.filter(g => g.id !== id);
				renderStyleGroupsList();
				updateUnifiedPreview();
			}
		};
		
		// Update unified preview
		function updateUnifiedPreview() {
			if (!us_preview_queue) return;
			
			// Get values
			const gap = Number(us_chip_gap?.value) || 8;
			const padV = Number(us_chip_pad_v?.value) || 10;
			const padH = Number(us_chip_pad_h?.value) || 14;
			const radius = Number(us_chip_radius?.value) || 10;
			const fontSize = Number(us_font_size?.value) || 24;
			const fontWeight = us_font_weight?.value || '700';
			const fontColor = us_font_color?.value || '#ffffff';
			const fontFamily = us_font_family?.value === 'custom' ? 'system-ui' : (us_font_family?.value || 'system-ui');
			const textShadow = us_font_shadow?.checked ? '0 1px 2px rgba(0,0,0,0.5)' : 'none';
			
			// Get background
			let bgStyle = 'transparent';
			if (!us_bg_transparent?.checked) {
				const bgMode = us_bg_mode?.value || 'solid';
				if (bgMode === 'solid') {
					bgStyle = us_bg_color?.value || '#000000';
				} else if (bgMode === 'gradient') {
					bgStyle = getBgGradientCSS();
				}
			}
			
			us_preview.style.background = bgStyle;
			us_preview_queue.style.gap = gap + 'px';
			
			// Get default chip style (from "all" type group, or fallback)
			let defaultChipBg = '#000000';
			let defaultChipImage = null;
			const allGroup = styleGroups.find(g => g.type === 'all');
			if (allGroup) {
				if (allGroup.bgMode === 'image' && allGroup.image) {
					defaultChipImage = allGroup.image;
				} else if (allGroup.bgMode === 'gradient') {
					if (allGroup.gradStops && allGroup.gradStops.length >= 2) {
						const sorted = [...allGroup.gradStops].sort((a, b) => a.position - b.position);
						const stops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
						defaultChipBg = `linear-gradient(${allGroup.gradAngle || 180}deg, ${stops})`;
					} else {
						defaultChipBg = `linear-gradient(180deg, ${allGroup.gradColor1 || '#000'}, ${allGroup.gradColor2 || '#333'})`;
					}
				} else if (allGroup.bgMode === 'solid') {
					defaultChipBg = allGroup.bgColor;
				}
			}
			
			// Render sample chips - match actual overlay style exactly
			const samples = ['A', 'TAB', 'LSHIFT'];
			us_preview_queue.innerHTML = '';
			
			samples.forEach(label => {
				const chip = document.createElement('div');
				chip.className = 'chip';
				chip.textContent = label;
				
				// Apply background (image or color)
				if (defaultChipImage) {
					chip.style.backgroundImage = `url(${defaultChipImage})`;
					chip.style.backgroundSize = 'cover';
					chip.style.backgroundPosition = 'center';
					chip.style.backgroundColor = 'transparent';
				} else {
					chip.style.background = defaultChipBg;
				}
				
				chip.style.color = fontColor;
				chip.style.padding = `${padV}px ${padH}px`;
				chip.style.borderRadius = `${radius}px`;
				chip.style.fontSize = `${fontSize}px`;
				chip.style.fontWeight = fontWeight;
				chip.style.fontFamily = fontFamily;
				chip.style.textShadow = textShadow;
				chip.style.minWidth = '44px';
				chip.style.textAlign = 'center';
				chip.style.display = 'inline-flex';
				chip.style.alignItems = 'center';
				chip.style.justifyContent = 'center';
				// Match overlay keycap effect from chip.css
				chip.style.boxShadow = 'inset 0 0 0 2px rgba(255,255,255,0.12), inset 0 -2px 4px rgba(0,0,0,0.25), inset 0 2px 4px rgba(255,255,255,0.08)';
				us_preview_queue.appendChild(chip);
			});
		}
		
		// Load unified style config from server
		async function loadUnifiedStyleConfig() {
			try {
				// Load from existing overlay config for now
				const res = await fetch('/api/overlay-config');
				const c = await res.json();
				
				// Map to new unified structure
				if (us_bg_transparent) {
					us_bg_transparent.checked = c.background === 'rgba(0,0,0,0)' || c.background === 'transparent';
					if (usBgColorSection) usBgColorSection.style.display = us_bg_transparent.checked ? 'none' : 'block';
				}
				if (us_bg_color) us_bg_color.value = c.background?.startsWith('#') ? c.background : '#000000';
				if (us_chip_gap) us_chip_gap.value = c.chip_gap ?? 8;
				if (us_chip_pad_v) us_chip_pad_v.value = c.chip_pad_v ?? 10;
				if (us_chip_pad_h) us_chip_pad_h.value = c.chip_pad_h ?? 14;
				if (us_chip_radius) us_chip_radius.value = c.chip_radius ?? 10;
				if (us_font_size) us_font_size.value = c.chip_font_px ?? 24;
				if (us_font_weight) us_font_weight.value = String(c.chip_font_weight ?? 700);
				if (us_font_color) us_font_color.value = c.chip_fg ?? '#ffffff';
				
				// Load style groups from localStorage first
				const storedGroups = localStorage.getItem('keyviewer_style_groups');
				if (storedGroups) {
					try {
						styleGroups = JSON.parse(storedGroups);
					} catch(e) {
						styleGroups = [];
					}
				} else {
					styleGroups = [];
					
					// Convert existing all keys to a style group
					if (allKeysData && allKeysData.image) {
						styleGroups.push({
							id: 'all-keys',
							name: currentLanguage === 'ko' ? 'ëª¨ë“  í‚¤ (ì´ë¯¸ì§€)' : 'All Keys (Image)',
							type: 'all',
							keys: ['*'],
							bgMode: 'image',
							bgColor: '#000000',
							image: allKeysData.image,
							textOpacity: allKeysData.textOpacity
						});
					} else if (c.chip_bg) {
						// Use chip_bg as default all keys style
						const isGradient = c.color_mode === 'gradient';
						styleGroups.push({
							id: 'default-all',
							name: currentLanguage === 'ko' ? 'ê¸°ë³¸ ìŠ¤íƒ€ì¼' : 'Default Style',
							type: 'all',
							keys: ['*'],
							bgMode: isGradient ? 'gradient' : 'solid',
							bgColor: isGradient ? '#000000' : c.chip_bg,
							gradColor1: c.grad_color1 || '#000000',
							gradColor2: c.grad_color2 || '#333333'
						});
					}
				}
				
				renderStyleGroupsList();
				updateUnifiedPreview();
			} catch(e) {
				console.error('Failed to load unified style config:', e);
			}
		}
		
		// Save unified style config
		async function saveUnifiedStyleConfig() {
			// Build config from unified modal values
			const bgTransparent = us_bg_transparent?.checked;
			let background = 'rgba(0,0,0,0)';
			if (!bgTransparent) {
				const mode = us_bg_mode?.value || 'solid';
				if (mode === 'solid') {
					background = us_bg_color?.value || '#000000';
				} else if (mode === 'gradient') {
					background = getBgGradientCSS();
				}
			}
			
			// Get chip style from all-type group
			let chipBg = '#000000';
			
			const allGroup = styleGroups.find(g => g.type === 'all');
			if (allGroup) {
				if (allGroup.bgMode === 'gradient') {
					if (allGroup.gradStops && allGroup.gradStops.length >= 2) {
						const sorted = [...allGroup.gradStops].sort((a, b) => a.position - b.position);
						const stops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
						chipBg = `linear-gradient(${allGroup.gradAngle || 180}deg, ${stops})`;
					} else {
						chipBg = `linear-gradient(180deg, ${allGroup.gradColor1 || '#000'}, ${allGroup.gradColor2 || '#333'})`;
					}
				} else if (allGroup.bgMode === 'solid') {
					chipBg = allGroup.bgColor;
				}
			}
			
			const payload = {
				fade_in_ms: Number(ov_fade_in?.value) || 0,
				fade_out_ms: Number(ov_fade_out?.value) || 0,
				background: background,
				chip_bg: chipBg,
				chip_fg: us_font_color?.value || '#ffffff',
				chip_gap: Number(us_chip_gap?.value) || 8,
				chip_pad_v: Number(us_chip_pad_v?.value) || 10,
				chip_pad_h: Number(us_chip_pad_h?.value) || 14,
				chip_radius: Number(us_chip_radius?.value) || 10,
				chip_font_px: Number(us_font_size?.value) || 24,
				chip_font_weight: Number(us_font_weight?.value) || 700,
				cols: Number(ov_cols?.value) || 8,
				rows: Number(ov_rows?.value) || 1,
				align: ov_align?.value || 'left',
				direction: ov_direction?.value || 'ltr'
			};
			
			try {
				await fetch('/api/overlay-config', { 
					method: 'POST', 
					headers: { 'Content-Type': 'application/json' }, 
					body: JSON.stringify(payload) 
				});
				
				// Save style groups to localStorage
				localStorage.setItem('keyviewer_style_groups', JSON.stringify(styleGroups));
				
				// Also save to key images format for overlay compatibility
				keyGroupsData = styleGroups.filter(g => g.type !== 'all' && g.bgMode === 'image' && g.image).map(g => ({
					keys: g.keys,
					image: g.image,
					textOpacity: g.textOpacity
				}));
				const allGroup = styleGroups.find(g => g.type === 'all');
				if (allGroup && allGroup.bgMode === 'image' && allGroup.image) {
					allKeysData = { image: allGroup.image, textOpacity: allGroup.textOpacity };
				} else {
					allKeysData = null; // Clear if not using image
				}
				saveKeyImagesToStorage();
				
				closeModalUnifiedStyle();
				updatePreview();
			} catch(e) {
				console.error('Failed to save unified style config:', e);
			}
		}
		
		// Save button handler
		if (usStyleSave) {
			usStyleSave.addEventListener('click', saveUnifiedStyleConfig);
		}
		
		// Reset button handler
		if (usStyleReset) {
			usStyleReset.addEventListener('click', () => {
				if (us_bg_transparent) us_bg_transparent.checked = true;
				if (usBgColorSection) usBgColorSection.style.display = 'none';
				if (us_chip_gap) us_chip_gap.value = 8;
				if (us_chip_pad_v) us_chip_pad_v.value = 10;
				if (us_chip_pad_h) us_chip_pad_h.value = 14;
				if (us_chip_radius) us_chip_radius.value = 10;
				if (us_font_size) us_font_size.value = 24;
				if (us_font_weight) us_font_weight.value = '700';
				if (us_font_color) us_font_color.value = '#ffffff';
				if (us_font_shadow) us_font_shadow.checked = true;
				
				styleGroups = [{
					id: 'default-all',
					name: currentLanguage === 'ko' ? 'ê¸°ë³¸ ìŠ¤íƒ€ì¼' : 'Default Style',
					type: 'all',
					keys: ['*'],
					bgMode: 'solid',
					bgColor: '#000000'
				}];
				
				renderStyleGroupsList();
				updateUnifiedPreview();
			});
		}
		
		// Update preview on input changes
		['input', 'change'].forEach(evt => {
			[us_chip_gap, us_chip_pad_v, us_chip_pad_h, us_chip_radius, us_font_size, us_font_weight, us_font_color, us_bg_color].forEach(el => {
				if (el) el.addEventListener(evt, updateUnifiedPreview);
			});
		});

		// isValidHex is now in utils.js
		function setPickBtn(btn, val){ if (btn && isValidHex(val)) { btn.style.background = val; } }
        function hookColorPair(textEl, pickBtn, picker){
            pickBtn.addEventListener('click', (ev)=> {
                // Try native picker first
                try { if (picker.showPicker) { picker.showPicker(); return; } } catch(_){ }

                // Show custom palette popover near the button
                const rect = pickBtn.getBoundingClientRect();
                const pop = document.createElement('div');
                pop.className = 'color-popover';
                pop.style.left = Math.round(rect.left) + 'px';
                pop.style.top = Math.round(rect.bottom + 6) + 'px';

                // Preset swatches (Material-ish)
                const presets = ['#000000','#111111','#222222','#444444','#666666','#888888','#bbbbbb','#ffffff',
                                 '#ff0000','#ff6b6b','#ffa94d','#ffd43b','#94d82d','#38d9a9','#4dabf7','#845ef7'];
                const sw = document.createElement('div'); sw.className = 'swatches';
                presets.forEach(c => { const d = document.createElement('div'); d.className = 'swatch'; d.style.background = c; d.title = c; d.addEventListener('click', ()=> { textEl.value = c; setPickBtn(pickBtn, c); updatePreview(); remove(); }); sw.appendChild(d); });

                // Hex + native input row
                const row = document.createElement('div'); row.className = 'row';
                const hex = document.createElement('input'); hex.type = 'text'; hex.placeholder = '#rrggbb'; hex.value = textEl.value || '#000000';
                const native = document.createElement('input'); native.type = 'color'; native.value = (textEl.value && /^#([0-9a-fA-F]{6})$/.test(textEl.value)) ? textEl.value : '#000000';
                hex.addEventListener('input', ()=> { if (/^#([0-9a-fA-F]{6})$/.test(hex.value)) { native.value = hex.value; } });
                native.addEventListener('input', ()=> { hex.value = native.value; });

                // Actions
                const actions = document.createElement('div'); actions.className = 'actions';
                const btnOk = document.createElement('button'); btnOk.className = 'btn'; btnOk.textContent = 'OK';
                const btnCancel = document.createElement('button'); btnCancel.className = 'btn'; btnCancel.textContent = 'Cancel';
                btnOk.addEventListener('click', ()=> { if (/^#([0-9a-fA-F]{6})$/.test(hex.value)) { textEl.value = hex.value; setPickBtn(pickBtn, hex.value); updatePreview(); } remove(); });
                btnCancel.addEventListener('click', remove);

                actions.appendChild(btnCancel); actions.appendChild(btnOk);
                row.appendChild(hex); row.appendChild(native);
                pop.appendChild(sw); pop.appendChild(row); pop.appendChild(actions);
                document.body.appendChild(pop);

                // Close when clicking outside
                function onDoc(e){ if (!pop.contains(e.target) && e.target !== pickBtn) remove(); }
                function remove(){ document.removeEventListener('mousedown', onDoc, true); try { document.body.removeChild(pop); } catch(_){} }
                setTimeout(()=> document.addEventListener('mousedown', onDoc, true), 0);
            });
            picker.addEventListener('input', ()=> { textEl.value = picker.value; setPickBtn(pickBtn, textEl.value); updatePreview(); });
            textEl.addEventListener('input', ()=> { setPickBtn(pickBtn, textEl.value); updatePreview(); });
        }

		function updatePreview(){
			if (!ov_preview || !ov_preview_queue) return;
			const root = ov_preview;
			
			// Check for image from styleGroups (all keys)
			const allGroup = styleGroups.find(g => g.type === 'all');
			let chipImage = null;
			let chipBg = ov_chip_bg?.value || '#000000';
			if (allGroup && allGroup.bgMode === 'image' && allGroup.image) {
				chipImage = allGroup.image;
			} else if (allGroup && allGroup.bgMode === 'gradient') {
				if (allGroup.gradStops && allGroup.gradStops.length >= 2) {
					const sorted = [...allGroup.gradStops].sort((a, b) => a.position - b.position);
					const stops = sorted.map(s => `${s.color} ${s.position}%`).join(', ');
					chipBg = `linear-gradient(${allGroup.gradAngle || 180}deg, ${stops})`;
				} else {
					chipBg = `linear-gradient(180deg, ${allGroup.gradColor1 || '#000'}, ${allGroup.gradColor2 || '#333'})`;
				}
			} else if (allGroup && allGroup.bgMode === 'solid') {
				chipBg = allGroup.bgColor;
			}
			const chipFg = ov_chip_fg?.value || '#ffffff';
			const gap = Number(ov_gap?.value) || 8;
			const padV = Number(ov_pad_v?.value) || 10;
			const padH = Number(ov_pad_h?.value) || 14;
			const radius = Number(ov_radius?.value) || 10;
			const fontSize = Number(ov_font_px?.value) || 24;
			const fontWeight = Number(ov_font_w?.value) || 700;
			const bgVal = ov_bg_trans?.checked ? 'rgba(0,0,0,0)' : (ov_bg?.value || 'rgba(0,0,0,0)');
			const colsVal = Number(ov_cols?.value) || 8;
			const rowsVal = Number(ov_rows?.value) || 1;
			const alignMap = { left: 'flex-start', center: 'center', right: 'flex-end' };
			
			root.style.background = bgVal;

			// Set queue to flex row (horizontal)
			ov_preview_queue.style.display = 'flex';
			ov_preview_queue.style.flexWrap = 'wrap';
			ov_preview_queue.style.gap = gap + 'px';
			ov_preview_queue.style.justifyContent = alignMap[ov_align?.value] || 'flex-start';
			ov_preview_queue.style.direction = (ov_direction?.value === 'rtl') ? 'rtl' : 'ltr';

			// Rebuild preview chips: always Q,W,E,R but obey capacity when rows>0
			const labels = ['Q','W','E','R','A','S','D','F'];
			const cols = colsVal; const rows = rowsVal;
			let count = labels.length;
			if (rows > 0) { const cap = Math.max(1, cols * rows); count = Math.min(count, cap); }
			ov_preview_queue.innerHTML = '';
			
			// Get key image settings for preview
			const keyImages = getKeyImages();
			const hideKeyText = getHideKeyText();
			
			for (let i=0;i<count;i++){
				const k = labels[i];
				const chip = document.createElement('div');
				chip.className = 'chip';
				chip.textContent = labels[i];
				if (chipImage) {
					chip.style.backgroundImage = `url(${chipImage})`;
					chip.style.backgroundSize = 'cover';
					chip.style.backgroundPosition = 'center';
				} else {
					chip.style.background = chipBg;
				}
				chip.style.color = chipFg;
				chip.style.padding = padV + 'px ' + padH + 'px';
				chip.style.borderRadius = radius + 'px';
				chip.style.fontSize = fontSize + 'px';
				chip.style.fontWeight = fontWeight;
				chip.style.minWidth = '44px';
				chip.style.textAlign = 'center';
				chip.style.fontFamily = 'ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial';
				chip.style.display = 'inline-flex';
				chip.style.alignItems = 'center';
				chip.style.justifyContent = 'center';
				chip.style.boxShadow = 'inset 0 0 0 2px rgba(255,255,255,0.12), inset 0 -2px 4px rgba(0,0,0,0.25), inset 0 2px 4px rgba(255,255,255,0.08)';
				ov_preview_queue.appendChild(chip);
			}
		}

		['input','change'].forEach(evt=>{
			[ov_fade_in,ov_fade_out,ov_chip_bg,ov_chip_fg,ov_bg,ov_gap,ov_pad_v,ov_pad_h,ov_radius,ov_font_px,ov_font_w,ov_cols,ov_rows,ov_align,ov_direction].forEach(el=>{
				if (el) el.addEventListener(evt, updatePreview);
			});
		});

		async function loadOverlayConfig(){
			try{
				const res = await fetch('/api/overlay-config');
				const c = await res.json();
				
				// Helper to convert rgba to hex or use default
				function toHex(val, def) {
					if (!val) return def;
					if (val.startsWith('#')) return val;
					// Try to parse rgba
					const match = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
					if (match) {
						const r = parseInt(match[1]).toString(16).padStart(2, '0');
						const g = parseInt(match[2]).toString(16).padStart(2, '0');
						const b = parseInt(match[3]).toString(16).padStart(2, '0');
						return '#' + r + g + b;
					}
					return def;
				}
				
				if (ov_fade_in) ov_fade_in.value = c.fade_in_ms ?? 0;
				if (ov_fade_out) ov_fade_out.value = c.fade_out_ms ?? 0;
				
				// Check if background is transparent
				const isTrans = (typeof c.background === 'string') && (
					c.background.toLowerCase() === 'transparent' || 
					c.background === 'rgba(0,0,0,0)' ||
					c.background === 'rgba(0, 0, 0, 0)' ||
					c.background === '#00000000'
				);
				if (ov_bg_trans) ov_bg_trans.checked = !!isTrans;
				if (ov_bg) { ov_bg.disabled = !!isTrans; ov_bg.value = isTrans ? '#000000' : toHex(c.background, '#000000'); }
				if (ov_bg_pickBtn) ov_bg_pickBtn.disabled = !!isTrans;
				
				// Chip colors
				if (ov_chip_bg) ov_chip_bg.value = toHex(c.chip_bg, '#000000');
				if (ov_chip_fg) ov_chip_fg.value = toHex(c.chip_fg, '#ffffff');
				
				// Use defaults if values are 0 or missing
				if (ov_gap) ov_gap.value = c.chip_gap || 8;
				if (ov_pad_v) ov_pad_v.value = c.chip_pad_v || 10;
				if (ov_pad_h) ov_pad_h.value = c.chip_pad_h || 14;
				if (ov_radius) ov_radius.value = c.chip_radius || 10;
				if (ov_font_px) ov_font_px.value = c.chip_font_px || 24;
				if (ov_font_w) ov_font_w.value = c.chip_font_weight || 700;
				if (ov_cols) ov_cols.value = c.cols || 8;
				if (ov_rows) ov_rows.value = c.rows || 1;
				if (ov_align) ov_align.value = c.align || 'left';
				if (ov_direction) ov_direction.value = c.direction || 'ltr';
				
				if (ov_bg_pickBtn && ov_bg) setPickBtn(ov_bg_pickBtn, ov_bg.value);
				if (ov_chip_bg_pickBtn && ov_chip_bg) setPickBtn(ov_chip_bg_pickBtn, ov_chip_bg.value);
				if (ov_chip_fg_pickBtn && ov_chip_fg) setPickBtn(ov_chip_fg_pickBtn, ov_chip_fg.value);
				updatePreview();
			}catch(e){ console.error('Failed to load overlay config:', e); }
		}

		async function saveOverlayConfig(overridePayload = null){
			const payload = overridePayload || {
				fade_in_ms: Number(ov_fade_in?.value) || 0,
				fade_out_ms: Number(ov_fade_out?.value) || 0,
				background: (ov_bg_trans?.checked !== false ? 'rgba(0,0,0,0)' : (ov_bg?.value || 'rgba(0,0,0,0)')),
				chip_bg: ov_chip_bg?.value || '#000000',
				chip_fg: ov_chip_fg?.value || '#ffffff',
				chip_gap: Number(ov_gap?.value) || 8,
				chip_pad_v: Number(ov_pad_v?.value) || 10,
				chip_pad_h: Number(ov_pad_h?.value) || 14,
				chip_radius: Number(ov_radius?.value) || 10,
				chip_font_px: Number(ov_font_px?.value) || 24,
				chip_font_weight: Number(ov_font_w?.value) || 700,
				cols: Number(ov_cols?.value) || 8,
				rows: Number(ov_rows?.value) || 1,
				align: ov_align?.value || 'left',
				direction: ov_direction?.value || 'ltr'
			};
			try{
				await fetch('/api/overlay-config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
			}catch(e){}
			if (!overridePayload) closeModalOverlay();
		}

		async function refreshTarget(){
			try {
				const res = await fetch('/api/target');
				const j = await res.json();
				modeEl.value = j.mode || 'process'; // ê¸°ë³¸ê°’: í”„ë¡œì„¸ìŠ¤
				valuePick.value = j.value || '';
				savedValue = j.value || '';
				
				if (j.mode === 'disabled') {
					currentStatus = currentLanguage === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (j.mode === 'all') {
					currentStatus = currentLanguage === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (j.value) {
					currentStatus = currentLanguage === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else {
					currentStatus = currentLanguage === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
				
				refreshPickerForMode();
				updateDebugInfo();
			} catch (e) {
				// If server is not available, try to restore from localStorage (Portable mode)
				try {
					const lastMode = localStorage.getItem('last_mode');
					const lastValue = localStorage.getItem('last_value');
					if (lastMode) {
						modeEl.value = lastMode;
						savedValue = lastValue || '';
						
						// Auto-apply if we have saved settings
						if (lastMode !== 'disabled' && lastValue) {
							await doApply(lastMode, lastValue);
						}
					}
				} catch(localErr) {
					// If localStorage fails, use defaults
					modeEl.value = 'disabled';
					savedValue = '';
				}
				
				refreshPickerForMode();
				updateDebugInfo();
			}
		}

		async function apply(){
			const m = modeEl.value;
			if (m === 'all') { openModalAll(); return; }
			await doApply(m, valuePick.value || null);
		}

		async function doApply(mode, value){
			statusEl.textContent = currentLanguage === 'ko' ? 'ì €ì¥ ì¤‘...' : 'Saving...';
			updateDebugInfo();
			try{
				await fetch('/api/target', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode, value }) });
				statusEl.textContent = currentLanguage === 'ko' ? 'ì ìš©ë¨' : 'Applied';
				savedValue = value || '';
				
				// Save to localStorage for portable
				try {
					localStorage.setItem('last_mode', mode);
					localStorage.setItem('last_value', value || '');
				} catch(e) {}
				
				// ì ìš© í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
				if (mode === 'disabled') {
					currentStatus = currentLanguage === 'ko' ? 'ë¹„í™œì„±í™”' : 'Disabled';
				} else if (mode === 'all') {
					currentStatus = currentLanguage === 'ko' ? 'ëª¨ë“  ì°½ í™œì„±í™”' : 'All Windows Active';
				} else if (value) {
					currentStatus = currentLanguage === 'ko' ? 'í™œì„±í™”' : 'Active';
				} else {
					currentStatus = currentLanguage === 'ko' ? 'ì„¤ì • ì•ˆë¨' : 'Not Configured';
				}
				
				updateDebugInfo();
			}catch(e){ 
				statusEl.textContent = currentLanguage === 'ko' ? 'ì˜¤ë¥˜' : 'Error'; 
				updateDebugInfo();
			}
		}

		function setSort(newKey){
			if (sortKey === newKey){ sortDir = (sortDir === 'asc') ? 'desc' : 'asc'; }
			else { sortKey = newKey; sortDir = 'asc'; }
			updateHeaderArrows();
			// Re-render
			fillTable();
			refreshPickerForMode();
		}

		function updateHeaderArrows(){
			Object.keys(arrowMap).forEach(k => { 
				if (arrowMap[k] && typeof arrowMap[k].textContent !== 'undefined') {
					arrowMap[k].textContent = ''; 
				}
			});
			const arr = arrowMap[sortKey];
			if (arr && typeof arr.textContent !== 'undefined') {
				arr.textContent = (sortDir === 'asc') ? 'â–²' : 'â–¼';
			}
		}

		function sortWindows(list){
			const dir = (sortDir === 'asc') ? 1 : -1;
			const copy = Array.from(list || []);
			copy.sort((a,b)=>{
				let av = a?.[sortKey] ?? '';
				let bv = b?.[sortKey] ?? '';
				if (sortKey === 'hwnd'){
					const an = Number(av)||0, bn = Number(bv)||0;
					if (an === bn) return 0;
					return an < bn ? -dir : dir;
				}
				av = String(av);
				bv = String(bv);
				const cmp = av.localeCompare(bv);
				return cmp * dir;
			});
			return copy;
		}

		function fillTable(){
			const sorted = sortWindows(lastWindows);
			if (winTableBody){
				winTableBody.innerHTML = sorted.map(w => `
					<tr data-title="${w.title||''}" data-process="${w.process||''}" data-hwnd="${w.hwnd||''}" data-class="${w.class||''}" class="window-row">
						<td title="${w.title||''}">${w.title||''}</td>
						<td title="${w.process||''}">${w.process||''}</td>
						<td title="${w.hwnd||''}">${w.hwnd||''}</td>
						<td title="${w.class||''}">${w.class||''}</td>
					</tr>
				`).join('');
				
				// Attach row click handlers for auto-target selection
				winTableBody.querySelectorAll('tr.window-row').forEach(tr => {
					tr.style.cursor = 'pointer';
					tr.addEventListener('click', async () => {
						let currentMode = modeEl.value;
						
						// If mode is disabled, automatically change to process mode
						if (currentMode === 'disabled') {
							modeEl.value = 'process';
							currentMode = 'process';
							refreshPickerForMode(); // Update picker options for process mode
						}
						
						// If no mode selected, default to process
						if (!currentMode || currentMode === '') {
							modeEl.value = 'process';
							currentMode = 'process';
						}
						
						// Skip for "all" mode
						if (currentMode === 'all') {
							return; // Do nothing for all mode
						}
						
						// Get value based on current mode
						let targetValue = '';
						if (currentMode === 'title') targetValue = tr.getAttribute('data-title');
						else if (currentMode === 'process') targetValue = tr.getAttribute('data-process');
						else if (currentMode === 'hwnd') targetValue = tr.getAttribute('data-hwnd');
						else if (currentMode === 'class') targetValue = tr.getAttribute('data-class');
						
						if (!targetValue) return;
						
						// Auto-apply the selected value
						valuePick.value = targetValue;
						await doApply(currentMode, targetValue);
						
						// Save to localStorage for portable
						try {
							localStorage.setItem('last_mode', currentMode);
							localStorage.setItem('last_value', targetValue);
						} catch(e) {}
					});
				});
			}
		}

		async function loadWindows(){
			try{
				const res = await fetch('/api/windows');
				const list = await res.json();
				lastWindows = Array.isArray(list) ? list : [];
				fillTable();
				
				if (!valuePick.matches(':focus') && document.activeElement !== valuePick) {
					refreshPickerForMode();
				}
			}catch(e){
				lastWindows = [];
				if (winTableBody){ winTableBody.innerHTML = ''; }
				
				if (!valuePick.matches(':focus') && document.activeElement !== valuePick) {
					refreshPickerForMode();
				}
			}
		}

		function refreshPickerForMode(){
			const m = modeEl.value;
			
			let values = [];
			if (m === 'title') values = lastWindows.map(w => w.title).filter(Boolean);
			if (m === 'process') values = lastWindows.map(w => w.process).filter(Boolean);
			if (m === 'class') values = lastWindows.map(w => w.class).filter(Boolean);
			if (m === 'hwnd') values = lastWindows.map(w => w.hwnd).filter(Boolean);
			const uniq = Array.from(new Set(values));
			if (m === 'hwnd') uniq.sort((a,b)=> ((Number(a)||0) - (Number(b)||0)) * (sortDir==='asc'?1:-1));
			else uniq.sort((a,b)=> String(a||'').localeCompare(String(b||'')) * (sortDir==='asc'?1:-1));
			
			const selectText = currentLanguage === 'ko' ? 'ì„ íƒ...' : 'Select...';
			valuePick.innerHTML = `<option value="">${selectText}</option>` + uniq.map(v => `<option value="${String(v)}">${String(v)}</option>`).join('');
			
			// í•­ìƒ ì €ì¥ëœ ê°’ë§Œ í‘œì‹œ (ì‚¬ìš©ìê°€ ì„ íƒí•œ ê°’ ë¬´ì‹œ)
			if (savedValue && uniq.includes(savedValue)) {
				valuePick.value = savedValue;
			} else {
				valuePick.value = '';
			}
			
			updateDebugInfo();
		}

		async function loadConfig(){
			// Port configuration is now handled in the launcher
			// This function is kept for future use if needed
		}

		async function loadForeground(){
			try{
				const res = await fetch('/api/foreground');
				const j = await res.json();
				fginfoEl.textContent = `HWND=${j.hwnd||''} | TITLE=${j.title||''} | PROCESS=${j.process_name||''} | CLASS=${j.class||''}`;
			}catch(e){
				fginfoEl.textContent = currentLanguage === 'ko' ? 'ì½ê¸° ì‹¤íŒ¨' : 'Read Failed';
			}
		}

		document.getElementById('apply').addEventListener('click', apply);
		// document.getElementById('savePort').addEventListener('click', savePort); // Removed savePort
		// valuePick.addEventListener('change', ()=>{ updateDebugInfo(); }); // ì‚¬ìš©ìê°€ ì„ íƒí•œ ê°’ì€ ì €ì¥ ì „ê¹Œì§€ ë¬´ì‹œ
		modeEl.addEventListener('change', ()=> { 
			refreshPickerForMode(); 
			updateDebugInfo();
		});
		openOverlayCfg.addEventListener('click', async ()=>{ await loadOverlayConfig(); openModalOverlay(); });
		closeOverlay.addEventListener('click', ()=> closeModalOverlay());
		saveOverlay.addEventListener('click', saveOverlayConfig);
		
		// Reset to default overlay settings
		const resetOverlayBtn = document.getElementById('resetOverlay');
		if (resetOverlayBtn) {
			resetOverlayBtn.addEventListener('click', () => {
				if (ov_fade_in) ov_fade_in.value = 0;
				if (ov_fade_out) ov_fade_out.value = 0;
				if (ov_bg_trans) ov_bg_trans.checked = true;
				if (ov_bg) { ov_bg.value = '#000000'; ov_bg.disabled = true; }
				if (ov_bg_pickBtn) ov_bg_pickBtn.disabled = true;
				if (ov_chip_bg) ov_chip_bg.value = '#000000';
				if (ov_chip_fg) ov_chip_fg.value = '#ffffff';
				if (ov_gap) ov_gap.value = 8;
				if (ov_pad_v) ov_pad_v.value = 10;
				if (ov_pad_h) ov_pad_h.value = 14;
				if (ov_radius) ov_radius.value = 10;
				if (ov_font_px) ov_font_px.value = 24;
				if (ov_font_w) ov_font_w.value = 700;
				if (ov_cols) ov_cols.value = 8;
				if (ov_rows) ov_rows.value = 1;
				if (ov_align) ov_align.value = 'left';
				if (ov_direction) ov_direction.value = 'ltr';
				if (ov_bg_pickBtn && ov_bg) setPickBtn(ov_bg_pickBtn, ov_bg.value);
				if (ov_chip_bg_pickBtn && ov_chip_bg) setPickBtn(ov_chip_bg_pickBtn, ov_chip_bg.value);
				if (ov_chip_fg_pickBtn && ov_chip_fg) setPickBtn(ov_chip_fg_pickBtn, ov_chip_fg.value);
				updatePreview();
			});
		}

		cancelAll.addEventListener('click', ()=>{ closeModalAll(); });
		saveAll.addEventListener('click', async ()=>{
			await doApply('all', null);
			closeModalAll();
		});

		if (ov_bg && ov_bg_pickBtn && ov_bg_picker) hookColorPair(ov_bg, ov_bg_pickBtn, ov_bg_picker);
		if (ov_chip_bg && ov_chip_bg_pickBtn && ov_chip_bg_picker) hookColorPair(ov_chip_bg, ov_chip_bg_pickBtn, ov_chip_bg_picker);
		if (ov_chip_fg && ov_chip_fg_pickBtn && ov_chip_fg_picker) hookColorPair(ov_chip_fg, ov_chip_fg_pickBtn, ov_chip_fg_picker);
		if (ov_bg_trans) ov_bg_trans.addEventListener('change', ()=> { if (ov_bg) ov_bg.disabled = ov_bg_trans.checked; if (ov_bg_pickBtn) ov_bg_pickBtn.disabled = ov_bg_trans.checked; updatePreview(); });
		
		// Simple color sync for Unified Style Modal (color picker + text input)
		function syncColorPair(picker, text) {
			if (!picker || !text) return;
			picker.addEventListener('input', () => { text.value = picker.value; updateUnifiedPreview(); });
			text.addEventListener('input', () => { if (/^#[0-9A-Fa-f]{6}$/.test(text.value)) picker.value = text.value; updateUnifiedPreview(); });
		}
		
		const us_bg_color_picker = document.getElementById('us_bg_color_picker');
		const us_font_color_picker = document.getElementById('us_font_color_picker');
		const usGroupBgColor_picker = document.getElementById('usGroupBgColor_picker');
		syncColorPair(us_bg_color_picker, us_bg_color);
		syncColorPair(us_font_color_picker, us_font_color);
		syncColorPair(usGroupBgColor_picker, document.getElementById('usGroupBgColor'));
		
		// ========== Gradient Editors (using GradientEditor class from gradient-editor.js) ==========
		
		// Group Gradient Editor
		const groupGradEditor = new GradientEditor({
			containerId: 'usGroupBgGrad',
			previewId: 'usGroupGradPreview',
			angleId: 'usGroupGradAngle',
			angleNumId: 'usGroupGradAngleNum',
			stopsId: 'usGroupGradStops',
			addBtnId: 'usGroupGradAdd',
			onChange: () => {} // Group changes are saved on button click
		});
		
		// Background Gradient Editor
		const bgGradEditor = new GradientEditor({
			containerId: 'usBgGradient',
			previewId: 'us_bg_grad_preview',
			angleId: 'us_bg_grad_angle',
			angleNumId: 'us_bg_grad_angle_num',
			stopsId: 'us_bg_grad_stops',
			addBtnId: 'us_bg_grad_add',
			onChange: updateUnifiedPreview
		});
		
		// Wrapper functions for compatibility
		function resetGroupGrad() {
			groupGradEditor.reset();
		}
		
		function renderBgGradStops() {
			bgGradEditor.render();
		}
		
		function renderGroupGradStops() {
			groupGradEditor.render();
		}
		
		function getBgGradientCSS() {
			return bgGradEditor.getCSS();
		}
		
		function getGroupGradientCSS() {
			return groupGradEditor.getCSS();
		}

		// Unified Style Modal events
		openUnifiedStyle.addEventListener('click', openModalUnifiedStyle);
		usStyleClose.addEventListener('click', closeModalUnifiedStyle);
		modalUnifiedStyle.addEventListener('click', (e) => { if (e.target === modalUnifiedStyle) closeModalUnifiedStyle(); });
		

		// ==================== Image Editor ====================
		const modalImageEditor = document.getElementById('modalImageEditor');
		const imgEditorCanvas = document.getElementById('imgEditorCanvas');
		const imgEditorCtx = imgEditorCanvas.getContext('2d');
		const imgZoom = document.getElementById('imgZoom');
		const imgZoomVal = document.getElementById('imgZoomVal');
		const imgKeyType = document.getElementById('imgKeyType');
		const imgQuality = document.getElementById('imgQuality');
		const imgQualityVal = document.getElementById('imgQualityVal');
		const imgSizeInfo = document.getElementById('imgSizeInfo');
		const imgHideText = document.getElementById('imgHideText');
		const imgEditorSave = document.getElementById('imgEditorSave');
		const imgEditorCancel = document.getElementById('imgEditorCancel');
		const editorPreviewContainer = document.getElementById('editorPreviewContainer');
		const imgChipMask = document.getElementById('imgChipMask');
		const imgChipArea = document.getElementById('imgChipArea');
		// New preview chips: Small, Medium, Large
		const previewChipSmall = document.getElementById('previewChipSmall');
		const previewChipMedium = document.getElementById('previewChipMedium');
		const previewChipLarge = document.getElementById('previewChipLarge');

		let editorImage = null;
		let editorHasChanges = false;
		let editorOffsetX = 0;
		let editorOffsetY = 0;
		let editorZoom = 1;
		let editorDragging = false;
		let editorLastX = 0;
		let editorLastY = 0;
		let editorCallback = null;
		let editorKeyType = 'normal';

		// Key type dimensions (for cropping)
		const KEY_SIZES = {
			normal: { w: 52, h: 52, ratio: 1 },
			wide: { w: 78, h: 52, ratio: 1.5 },
			'extra-wide': { w: 120, h: 52, ratio: 2.3 }
		};

		function openImageEditor(imageSrc, keyType, callback) {
			editorCallback = callback;
			editorKeyType = 'wide'; // Always use wide (medium) key type
			imgKeyType.value = editorKeyType;
			editorHasChanges = false;
			editorZoom = 1;
			editorOffsetX = 0;
			editorOffsetY = 0;
			imgZoom.value = 100;
			imgZoomVal.textContent = '100%';
			imgQuality.value = 70;
			imgQualityVal.textContent = '70%';
			imgHideText.checked = false;

			editorImage = new Image();
			editorImage.onload = () => {
				// Set canvas size based on key type
				const size = KEY_SIZES[editorKeyType];
				const canvasW = 400;
				const canvasH = Math.round(canvasW / size.ratio);
				imgEditorCanvas.width = canvasW;
				imgEditorCanvas.height = canvasH;
				
				// Center image initially
				editorOffsetX = (canvasW - editorImage.width) / 2;
				editorOffsetY = (canvasH - editorImage.height) / 2;
				
				drawEditor();
				updateEditorPreview();
				modalImageEditor.style.display = 'flex';
			};
			editorImage.src = imageSrc;
		}

		function drawEditor() {
			if (!editorImage) return;
			const ctx = imgEditorCtx;
			const w = imgEditorCanvas.width;
			const h = imgEditorCanvas.height;

			// Clear
			ctx.fillStyle = '#1a1a1a';
			ctx.fillRect(0, 0, w, h);

			// Draw image
			const imgW = editorImage.width * editorZoom;
			const imgH = editorImage.height * editorZoom;
			ctx.drawImage(editorImage, editorOffsetX, editorOffsetY, imgW, imgH);

			// Draw crop overlay (darken outside area)
			const cropSize = KEY_SIZES[editorKeyType];
			const cropW = w * 0.7;
			const cropH = cropW / cropSize.ratio;
			const cropX = (w - cropW) / 2;
			const cropY = (h - cropH) / 2;

			// Darken outside
			ctx.fillStyle = 'rgba(0,0,0,0.6)';
			ctx.fillRect(0, 0, w, cropY); // top
			ctx.fillRect(0, cropY + cropH, w, h - cropY - cropH); // bottom
			ctx.fillRect(0, cropY, cropX, cropH); // left
			ctx.fillRect(cropX + cropW, cropY, w - cropX - cropW, cropH); // right

			// Draw crop border with key shape effect
			ctx.strokeStyle = 'rgba(255,255,255,0.3)';
			ctx.lineWidth = 2;
			ctx.beginPath();
			roundRect(ctx, cropX, cropY, cropW, cropH, 8);
			ctx.stroke();

			// Inner highlight (key shape effect)
			ctx.strokeStyle = 'rgba(255,255,255,0.1)';
			ctx.lineWidth = 4;
			ctx.beginPath();
			roundRect(ctx, cropX + 4, cropY + 4, cropW - 8, cropH - 8, 6);
			ctx.stroke();
		}

		function roundRect(ctx, x, y, w, h, r) {
			ctx.moveTo(x + r, y);
			ctx.lineTo(x + w - r, y);
			ctx.quadraticCurveTo(x + w, y, x + w, y + r);
			ctx.lineTo(x + w, y + h - r);
			ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
			ctx.lineTo(x + r, y + h);
			ctx.quadraticCurveTo(x, y + h, x, y + h - r);
			ctx.lineTo(x, y + r);
			ctx.quadraticCurveTo(x, y, x + r, y);
		}

		function getCroppedImage() {
			if (!editorImage) return null;
			
			const w = imgEditorCanvas.width;
			const h = imgEditorCanvas.height;
			const cropSize = KEY_SIZES[editorKeyType];
			const cropW = w * 0.7;
			const cropH = cropW / cropSize.ratio;
			const cropX = (w - cropW) / 2;
			const cropY = (h - cropH) / 2;

			// Create temp canvas for cropped area
			const tempCanvas = document.createElement('canvas');
			const outputW = cropSize.w * 2; // 2x for quality
			const outputH = cropSize.h * 2;
			tempCanvas.width = outputW;
			tempCanvas.height = outputH;
			const tempCtx = tempCanvas.getContext('2d');

			// Calculate source coordinates
			const imgW = editorImage.width * editorZoom;
			const imgH = editorImage.height * editorZoom;
			
			// Source rect in original image coordinates
			const srcX = (cropX - editorOffsetX) / editorZoom;
			const srcY = (cropY - editorOffsetY) / editorZoom;
			const srcW = cropW / editorZoom;
			const srcH = cropH / editorZoom;

			tempCtx.drawImage(editorImage, srcX, srcY, srcW, srcH, 0, 0, outputW, outputH);

			// Compress with quality
			const quality = imgQuality.value / 100;
			return tempCanvas.toDataURL('image/webp', quality);
		}

		function updateEditorPreview() {
			const croppedUrl = getCroppedImage();
			if (!croppedUrl) return;

			editorHasChanges = true;

			// Update size info
			const sizeKB = Math.round(croppedUrl.length * 0.75 / 1024);
			if (imgSizeInfo) imgSizeInfo.textContent = `~${sizeKB}KB`;

			// Get actual style values from overlay/unified settings
			const chipFg = ov_chip_fg?.value || us_font_color?.value || '#ffffff';
			const padV = Number(ov_pad_v?.value) || Number(us_chip_pad_v?.value) || 10;
			const padH = Number(ov_pad_h?.value) || Number(us_chip_pad_h?.value) || 14;
			const radius = Number(ov_radius?.value) || Number(us_chip_radius?.value) || 10;
			const fontSize = Number(ov_font_px?.value) || Number(us_font_size?.value) || 24;
			const fontWeight = Number(ov_font_w?.value) || Number(us_font_weight?.value) || 700;
			const hideText = imgHideText?.checked;

			// Update chip mask area in canvas
			if (imgChipArea) {
				const canvasW = imgEditorCanvas.width;
				const canvasH = imgEditorCanvas.height;
				const cropSize = KEY_SIZES[editorKeyType];
				const cropW = canvasW * 0.7;
				const cropH = cropW / cropSize.ratio;
				imgChipArea.style.width = `${cropW}px`;
				imgChipArea.style.height = `${cropH}px`;
				imgChipArea.style.borderRadius = `${radius}px`;
			}

			// Update all three preview chips: Small / Medium / Large
			const chips = [
				{ el: previewChipSmall, label: 'A', scale: 0.8 },
				{ el: previewChipMedium, label: 'TAB', scale: 1.0 },
				{ el: previewChipLarge, label: 'LSHIFT', scale: 1.3 }
			];
			
			chips.forEach(({ el: chip, label, scale }) => {
				if (!chip) return;
				
				// Clear existing content
				chip.innerHTML = '';
				
				// Apply all dynamic styles explicitly with scale
				chip.style.backgroundImage = `url(${croppedUrl})`;
				chip.style.backgroundSize = 'cover';
				chip.style.backgroundPosition = 'center';
				chip.style.backgroundRepeat = 'no-repeat';
				chip.style.padding = `${padV * scale}px ${padH * scale}px`;
				chip.style.borderRadius = `${radius}px`;
				chip.style.fontSize = `${fontSize * scale}px`;
				chip.style.fontWeight = fontWeight;
				chip.style.boxShadow = 'inset 0 0 0 2px rgba(255,255,255,0.12), inset 0 -2px 4px rgba(0,0,0,0.25), inset 0 2px 4px rgba(255,255,255,0.08)';
				chip.style.display = 'inline-flex';
				chip.style.alignItems = 'center';
				chip.style.justifyContent = 'center';
				chip.style.minWidth = `${44 * scale}px`;
				chip.style.textAlign = 'center';
				chip.style.fontFamily = 'ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial';
				
				// Create text span
				const textSpan = document.createElement('span');
				textSpan.textContent = label;
				textSpan.style.color = hideText ? 'transparent' : chipFg;
				textSpan.style.textShadow = hideText ? 'none' : '0 1px 2px rgba(0,0,0,0.5)';
				chip.appendChild(textSpan);
			});
		}

		// Editor mouse events
		imgEditorCanvas.addEventListener('mousedown', e => {
			editorDragging = true;
			editorLastX = e.clientX;
			editorLastY = e.clientY;
		});

		window.addEventListener('mousemove', e => {
			if (!editorDragging) return;
			const dx = e.clientX - editorLastX;
			const dy = e.clientY - editorLastY;
			editorOffsetX += dx;
			editorOffsetY += dy;
			editorLastX = e.clientX;
			editorLastY = e.clientY;
			drawEditor();
			updateEditorPreview();
		});

		window.addEventListener('mouseup', () => {
			editorDragging = false;
		});

		// Scroll to zoom on canvas
		imgEditorCanvas.addEventListener('wheel', e => {
			e.preventDefault();
			const delta = e.deltaY > 0 ? -10 : 10;
			let newZoom = parseInt(imgZoom.value) + delta;
			newZoom = Math.max(100, Math.min(300, newZoom));
			imgZoom.value = newZoom;
			editorZoom = newZoom / 100;
			imgZoomVal.textContent = newZoom + '%';
			drawEditor();
			updateEditorPreview();
		}, { passive: false });

		imgZoom.addEventListener('input', () => {
			editorZoom = imgZoom.value / 100;
			imgZoomVal.textContent = imgZoom.value + '%';
			drawEditor();
			updateEditorPreview();
		});

		// Key type is now fixed to 'wide'

		imgQuality.addEventListener('input', () => {
			imgQualityVal.textContent = imgQuality.value + '%';
			updateEditorPreview();
		});

		// Text visibility checkbox
		imgHideText.addEventListener('change', () => {
			updateEditorPreview();
		});

		imgEditorSave.addEventListener('click', () => {
			const croppedImage = getCroppedImage();
			const textOpacity = imgHideText.checked ? 0 : 1;
			
			if (editorCallback) {
				editorCallback({
					image: croppedImage,
					keyType: editorKeyType,
					textOpacity: textOpacity
				});
			}
			editorHasChanges = false;
			modalImageEditor.style.display = 'none';
		});

		// Close editor with confirmation
		function closeImageEditor() {
			if (editorHasChanges) {
				const msg = currentLanguage === 'ko' 
					? 'ë³€ê²½ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ì €ì¥í•˜ì§€ ì•Šê³  ë‹«ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?' 
					: 'You have unsaved changes. Close without saving?';
				if (!confirm(msg)) return;
			}
			editorHasChanges = false;
			modalImageEditor.style.display = 'none';
		}

		imgEditorCancel.addEventListener('click', closeImageEditor);

		// Click outside modal to close
		modalImageEditor.addEventListener('click', (e) => {
			if (e.target === modalImageEditor) {
				closeImageEditor();
			}
		});

		// ==================== Key Image Data Management ====================
		// (UI moved to Unified Style Modal, this section handles data persistence only)

		// Key image data storage (used by export/import and overlay)
		let keyImagesData = {};
		let keyGroupsData = [];
		let allKeysData = null;

		// Load key images from localStorage
		function loadKeyImagesFromStorage() {
			try {
				const stored = localStorage.getItem('keyviewer_key_images');
				if (stored) {
					const data = JSON.parse(stored);
					keyImagesData = data.individual || {};
					keyGroupsData = data.groups || [];
					allKeysData = data.allKeys || null;
				}
			} catch (e) {
				console.error('Failed to load key images:', e);
			}
		}

		// Save key images to localStorage
		function saveKeyImagesToStorage() {
			try {
				const data = { individual: keyImagesData, groups: keyGroupsData, allKeys: allKeysData };
				localStorage.setItem('keyviewer_key_images', JSON.stringify(data));
				// Also notify server
				saveKeyImagesToServer();
			} catch (e) {
				console.error('Failed to save key images:', e);
			}
		}

		// Save to server
		async function saveKeyImagesToServer() {
			try {
				const payload = { individual: keyImagesData, groups: keyGroupsData, allKeys: allKeysData };
				await fetch('/api/key-images', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(payload)
				});
			} catch (e) {
				console.error('Failed to save key images to server:', e);
			}
		}

		// ==================== GitHub OAuth ====================
		const OAUTH_PROXY_URL = 'https://keyviewer-oauth.rudghrnt.workers.dev';
		
		// Header elements
		const headerLoginBtn = document.getElementById('headerLoginBtn');
		const headerLogoutBtn = document.getElementById('headerLogoutBtn');
		const headerLoggedOut = document.getElementById('headerLoggedOut');
		const headerLoggedIn = document.getElementById('headerLoggedIn');
		const headerAvatar = document.getElementById('headerAvatar');
		const headerUsername = document.getElementById('headerUsername');
		const headerImportBtn = document.getElementById('headerImportBtn');
		const headerExportBtn = document.getElementById('headerExportBtn');

		// Import/Export modals
		const modalImport = document.getElementById('modalImport');
		const modalExport = document.getElementById('modalExport');
		const closeImport = document.getElementById('closeImport');
		const closeExport = document.getElementById('closeExport');

		// Gist elements (in import modal)
		const gistListContainer = document.getElementById('gistListContainer');
		const gistPreviewSection = document.getElementById('gistPreviewSection');
		const gistPreviewName = document.getElementById('gistPreviewName');
		const gistPreviewDate = document.getElementById('gistPreviewDate');
		const gistPreviewInfo = document.getElementById('gistPreviewInfo');
		const loadSelectedGist = document.getElementById('loadSelectedGist');
		const refreshGistList = document.getElementById('refreshGistList');
		const gistImportId = document.getElementById('gistImportId');
		const gistImportBtn = document.getElementById('gistImportBtn');
		const jsonImportBtn = document.getElementById('jsonImportBtn');

		// Export elements
		const exportGistSection = document.getElementById('exportGistSection');
		const exportLoginRequired = document.getElementById('exportLoginRequired');
		const gistExportDesc = document.getElementById('gistExportDesc');
		const gistExportBtn = document.getElementById('gistExportBtn');
		const gistExportResult = document.getElementById('gistExportResult');
		const jsonExportBtn = document.getElementById('jsonExportBtn');

		let githubUser = null;
		let userGists = [];
		let selectedGist = null;
		let selectedGistData = null;

		// Check for token in URL (returned from OAuth)
		function checkOAuthCallback() {
			const urlParams = new URLSearchParams(window.location.search);
			const token = urlParams.get('github_token');
			
			if (token) {
				// Save token and clean URL
				localStorage.setItem('github_token', token);
				
				// Remove token from URL for security
				const cleanUrl = window.location.pathname;
				window.history.replaceState({}, document.title, cleanUrl);
				
				// Validate and show user info
				validateGitHubToken(token);
				
				console.log('[OAuth] Token received from callback');
			} else {
				// Check for saved token
				const savedToken = localStorage.getItem('github_token');
				if (savedToken) {
					validateGitHubToken(savedToken);
				}
			}
		}

		// Validate token and get user info
		async function validateGitHubToken(token) {
			try {
				const res = await fetch('https://api.github.com/user', {
					headers: {
						'Authorization': `token ${token}`,
						'Accept': 'application/vnd.github.v3+json'
					}
				});
				
				if (res.ok) {
					githubUser = await res.json();
					showGitHubUser(githubUser);
					console.log('[OAuth] User validated:', githubUser.login);
				} else {
					// Token invalid, clear it
					localStorage.removeItem('github_token');
					showGitHubLoggedOut();
					console.log('[OAuth] Token invalid, cleared');
				}
			} catch (e) {
				console.error('[OAuth] Validation error:', e);
				showGitHubLoggedOut();
			}
		}

		function showGitHubUser(user) {
			// Update header
			headerAvatar.src = user.avatar_url;
			headerUsername.textContent = user.name || user.login;
			headerLoggedIn.style.display = 'flex';
			headerLoggedOut.style.display = 'none';
			
			// Update export modal
			exportGistSection.style.display = 'block';
			exportLoginRequired.style.display = 'none';
		}

		// Load user's gists that contain keyviewer preset
		async function loadUserGists() {
			const token = localStorage.getItem('github_token');
			if (!token) {
				gistListContainer.innerHTML = `<div class="help" style="text-align:center; padding:12px">${currentLanguage === 'ko' ? 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' : 'Login required'}</div>`;
				return;
			}

			gistListContainer.innerHTML = `<div class="help" style="text-align:center; padding:12px">${currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...' : 'Loading...'}</div>`;
			gistPreviewSection.style.display = 'none';

			try {
				const res = await fetch('https://api.github.com/gists?per_page=100', {
					headers: {
						'Authorization': `token ${token}`,
						'Accept': 'application/vnd.github.v3+json'
					},
					cache: 'no-store'
				});

				if (!res.ok) throw new Error('Failed to fetch gists');

				const gists = await res.json();
				console.log('[Gist] Total gists:', gists.length);
				
				// Filter gists that have keyviewer-preset.json
				userGists = gists.filter(g => {
					if (!g.files) return false;
					return Object.keys(g.files).some(name => 
						name.toLowerCase() === 'keyviewer-preset.json'
					);
				});
				
				console.log('[Gist] KeyViewer presets found:', userGists.length);
				renderGistList();
			} catch (e) {
				console.error('[Gist] Failed to load:', e);
				gistListContainer.innerHTML = `<div class="help" style="text-align:center; padding:12px; color:#ff5b5b">${currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨' : 'Failed to load'}</div>`;
			}
		}

		// Render gist list
		function renderGistList() {
			if (userGists.length === 0) {
				gistListContainer.innerHTML = `<div class="help" style="text-align:center; padding:12px">${currentLanguage === 'ko' ? 'ì €ì¥ëœ í”„ë¦¬ì…‹ì´ ì—†ìŠµë‹ˆë‹¤' : 'No saved presets'}</div>`;
				return;
			}

			gistListContainer.innerHTML = userGists.map((g, idx) => {
				const date = new Date(g.updated_at).toLocaleDateString(currentLanguage === 'ko' ? 'ko-KR' : 'en-US');
				const desc = g.description || (currentLanguage === 'ko' ? '(ì„¤ëª… ì—†ìŒ)' : '(No description)');
				return `<div class="gist-item" data-idx="${idx}">
					<div style="flex:1">
						<div class="gist-name">${desc}</div>
						<div class="gist-date">${date}</div>
					</div>
				</div>`;
			}).join('');

			// Add click handlers
			gistListContainer.querySelectorAll('.gist-item').forEach(item => {
				item.addEventListener('click', () => selectGist(parseInt(item.dataset.idx)));
			});
		}

		// Select a gist and show preview
		async function selectGist(idx) {
			// Update UI selection
			gistListContainer.querySelectorAll('.gist-item').forEach((item, i) => {
				item.classList.toggle('selected', i === idx);
			});

			selectedGist = userGists[idx];
			selectedGistData = null;
			
			// Show preview section
			gistPreviewSection.style.display = 'block';
			gistPreviewName.textContent = selectedGist.description || (currentLanguage === 'ko' ? '(ì„¤ëª… ì—†ìŒ)' : '(No description)');
			gistPreviewDate.textContent = new Date(selectedGist.updated_at).toLocaleString(currentLanguage === 'ko' ? 'ko-KR' : 'en-US');
			gistPreviewInfo.textContent = currentLanguage === 'ko' ? 'ì •ë³´ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...' : 'Loading info...';

			// Fetch full gist data to show preview
			try {
				const token = localStorage.getItem('github_token');
				const res = await fetch(`https://api.github.com/gists/${selectedGist.id}`, {
					headers: token ? { 'Authorization': `token ${token}` } : {}
				});

				if (!res.ok) throw new Error('Failed to fetch gist');

				const gist = await res.json();
				const file = gist.files['keyviewer-preset.json'];
				if (file) {
					selectedGistData = JSON.parse(file.content);
					
					// Build preview info
					let info = [];
					if (selectedGistData.version >= 3) {
						// Version 3: styleGroups format
						const keyCount = Object.keys(selectedGistData.keyImages?.individual || {}).length;
						const styleGroupCount = (selectedGistData.styleGroups || []).length;
						const hasAllKeysImage = selectedGistData.keyImages?.allKeys?.image ? 1 : 0;
						info.push(`${currentLanguage === 'ko' ? 'ê°œë³„ í‚¤' : 'Individual keys'}: ${keyCount}`);
						info.push(`${currentLanguage === 'ko' ? 'ìŠ¤íƒ€ì¼ ê·¸ë£¹' : 'Style groups'}: ${styleGroupCount}`);
						if (hasAllKeysImage) info.push(`${currentLanguage === 'ko' ? 'ì „ì²´ í‚¤ ì´ë¯¸ì§€' : 'All keys image'}`);
						if (selectedGistData.overlay) {
							info.push(`${currentLanguage === 'ko' ? 'ì˜¤ë²„ë ˆì´ ì„¤ì •' : 'Overlay settings'}`);
						}
						info.push('(v3)');
					} else if (selectedGistData.version === 2) {
						const keyCount = Object.keys(selectedGistData.keyImages?.individual || {}).length;
						const groupCount = (selectedGistData.keyImages?.groups || []).length;
						info.push(`${currentLanguage === 'ko' ? 'í‚¤ ì´ë¯¸ì§€' : 'Key images'}: ${keyCount}`);
						info.push(`${currentLanguage === 'ko' ? 'ê·¸ë£¹' : 'Groups'}: ${groupCount}`);
						if (selectedGistData.overlay) {
							info.push(`${currentLanguage === 'ko' ? 'ì˜¤ë²„ë ˆì´ ì„¤ì • í¬í•¨' : 'Includes overlay settings'}`);
						}
						info.push('(v2)');
					} else {
						const keyCount = Object.keys(selectedGistData.individual || {}).length;
						const groupCount = (selectedGistData.groups || []).length;
						info.push(`${currentLanguage === 'ko' ? 'í‚¤ ì´ë¯¸ì§€' : 'Key images'}: ${keyCount}`);
						info.push(`${currentLanguage === 'ko' ? 'ê·¸ë£¹' : 'Groups'}: ${groupCount}`);
						info.push('(v1)');
					}
					gistPreviewInfo.textContent = info.join(' Â· ');
				}
			} catch (e) {
				console.error('Failed to fetch gist details:', e);
				gistPreviewInfo.textContent = currentLanguage === 'ko' ? 'ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨' : 'Failed to load info';
			}
		}

		// Load selected gist
		loadSelectedGist.addEventListener('click', async () => {
			if (!selectedGistData) {
				alert(currentLanguage === 'ko' ? 'í”„ë¦¬ì…‹ì„ ì„ íƒí•˜ì„¸ìš”' : 'Please select a preset');
				return;
			}

			await processImportedData(selectedGistData);
			alert(currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!' : 'Import successful!');
		});

		function showGitHubLoggedOut() {
			githubUser = null;
			userGists = [];
			selectedGist = null;
			selectedGistData = null;
			
			// Update header
			headerLoggedIn.style.display = 'none';
			headerLoggedOut.style.display = 'block';
			
			// Update export modal
			exportGistSection.style.display = 'none';
			exportLoginRequired.style.display = 'block';
			
			// Update gist list
			gistListContainer.innerHTML = `<div class="help" style="text-align:center; padding:12px">${currentLanguage === 'ko' ? 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' : 'Login required'}</div>`;
		}

		// Modal open/close handlers
		headerImportBtn.addEventListener('click', () => {
			modalImport.style.display = 'flex';
			if (githubUser) loadUserGists();
		});
		
		headerExportBtn.addEventListener('click', () => {
			modalExport.style.display = 'flex';
			updateExportPreview();
		});
		
		// Update export preview with current settings info
		function updateExportPreview() {
			const previewEl = document.getElementById('exportPreviewInfo');
			if (!previewEl) return;
			
			// Count from styleGroups (new system)
			const styleGroupCount = styleGroups.length;
			const imageGroupCount = styleGroups.filter(g => g.bgMode === 'image' && g.image).length;
			const allKeysGroup = styleGroups.find(g => g.type === 'all');
			
			// Also count legacy key images
			const keyCount = Object.keys(keyImagesData).length;
			const groupCount = keyGroupsData.length;
			const hasAllKeys = allKeysData && allKeysData.image;
			
			// Get overlay settings summary
			const cols = Number(ov_cols?.value) || 8;
			const rows = Number(ov_rows?.value) || 1;
			
			// Get chip colors from styleGroups or overlay settings
			let chipBg = '#000000';
			if (allKeysGroup) {
				if (allKeysGroup.bgMode === 'image' && allKeysGroup.image) {
					chipBg = 'ğŸ–¼ï¸ ì´ë¯¸ì§€';
				} else if (allKeysGroup.bgMode === 'gradient') {
					chipBg = `gradient`;
				} else {
					chipBg = allKeysGroup.bgColor || '#000000';
				}
			} else {
				chipBg = ov_chip_bg?.value || '#000000';
			}
			const chipFg = ov_chip_fg?.value || '#ffffff';
			
			const lines = [];
			
			// Style groups info
			lines.push(`<div style="margin-bottom:6px"><strong>${currentLanguage === 'ko' ? 'ğŸ¨ ìŠ¤íƒ€ì¼ ê·¸ë£¹' : 'ğŸ¨ Style Groups'}</strong></div>`);
			if (styleGroupCount > 0) {
				lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ì´ ê·¸ë£¹' : 'Total groups'}: ${styleGroupCount}${currentLanguage === 'ko' ? 'ê°œ' : ''}</div>`);
				if (imageGroupCount > 0) {
					lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ì´ë¯¸ì§€ ì‚¬ìš©' : 'With images'}: ${imageGroupCount}${currentLanguage === 'ko' ? 'ê°œ' : ''}</div>`);
				}
			} else {
				lines.push(`<div style="margin-left:12px; color:var(--muted)">${currentLanguage === 'ko' ? 'ì„¤ì •ëœ ê·¸ë£¹ ì—†ìŒ' : 'No groups configured'}</div>`);
			}
			
			// Overlay settings info
			lines.push(`<div style="margin-top:8px; margin-bottom:6px"><strong>${currentLanguage === 'ko' ? 'âš™ï¸ ì˜¤ë²„ë ˆì´ ì„¤ì •' : 'âš™ï¸ Overlay Settings'}</strong></div>`);
			lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ë ˆì´ì•„ì›ƒ' : 'Layout'}: ${cols} Ã— ${rows}</div>`);
			
			// Chip background display
			if (chipBg === 'ğŸ–¼ï¸ ì´ë¯¸ì§€' || chipBg === 'gradient') {
				lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ì¹© ë°°ê²½' : 'Chip BG'}: ${chipBg === 'gradient' ? 'ê·¸ë¼ë°ì´ì…˜' : chipBg}</div>`);
			} else {
				lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ì¹© ìƒ‰ìƒ' : 'Chip colors'}: <span style="display:inline-block;width:14px;height:14px;background:${chipBg};border-radius:3px;vertical-align:middle;border:1px solid var(--border)"></span> / <span style="display:inline-block;width:14px;height:14px;background:${chipFg};border-radius:3px;vertical-align:middle;border:1px solid var(--border)"></span></div>`);
			}
			lines.push(`<div style="margin-left:12px">â€¢ ${currentLanguage === 'ko' ? 'ì •ë ¬' : 'Align'}: ${ov_align?.value || 'left'}</div>`);
			
			previewEl.innerHTML = lines.join('');
		}
		
		closeImport.addEventListener('click', () => {
			modalImport.style.display = 'none';
		});
		
		closeExport.addEventListener('click', () => {
			modalExport.style.display = 'none';
		});

		// Header GitHub Login button
		headerLoginBtn.addEventListener('click', () => {
			const port = window.location.port || '8000';
			const path = window.location.pathname || '/control';
			const authUrl = `${OAUTH_PROXY_URL}/auth?port=${port}&path=${encodeURIComponent(path)}`;
			
			window.location.href = authUrl;
		});

		// Header GitHub Logout button
		headerLogoutBtn.addEventListener('click', () => {
			localStorage.removeItem('github_token');
			showGitHubLoggedOut();
		});

		// Refresh gist list button
		refreshGistList.addEventListener('click', () => {
			if (githubUser) loadUserGists();
		});

		// Initialize OAuth on page load
		checkOAuthCallback();

		// ==================== Gist Import/Export ====================
		// Get current overlay config for export
		function getOverlayConfigForExport() {
			return {
				fade_in_ms: Number(ov_fade_in?.value) || 0,
				fade_out_ms: Number(ov_fade_out?.value) || 0,
				background: ov_bg_trans?.checked !== false ? 'rgba(0,0,0,0)' : (ov_bg?.value || 'rgba(0,0,0,0)'),
				chip_bg: ov_chip_bg?.value || '#000000',
				chip_fg: ov_chip_fg?.value || '#ffffff',
				chip_gap: Number(ov_gap?.value) || 8,
				chip_pad_v: Number(ov_pad_v?.value) || 10,
				chip_pad_h: Number(ov_pad_h?.value) || 14,
				chip_radius: Number(ov_radius?.value) || 10,
				chip_font_px: Number(ov_font_px?.value) || 24,
				chip_font_weight: Number(ov_font_w?.value) || 700,
				cols: Number(ov_cols?.value) || 8,
				rows: Number(ov_rows?.value) || 1,
				align: ov_align?.value || 'left',
				direction: ov_direction?.value || 'ltr'
			};
		}
		
		// Get style groups for export
		function getStyleGroupsForExport() {
			return styleGroups.map(g => ({
				id: g.id,
				name: g.name,
				type: g.type,
				keys: g.keys,
				bgMode: g.bgMode,
				bgColor: g.bgColor,
				gradStops: g.gradStops,
				gradAngle: g.gradAngle,
				gradColor1: g.gradColor1, // Legacy
				gradColor2: g.gradColor2, // Legacy
				image: g.image
			}));
		}

		// Apply imported overlay config
		async function applyImportedOverlayConfig(overlay) {
			if (!overlay) return;
			
			const isTrans = overlay.background === 'rgba(0,0,0,0)' || overlay.background === 'transparent';
			
			// Apply values with null checks
			if (ov_fade_in) ov_fade_in.value = overlay.fade_in_ms ?? 0;
			if (ov_fade_out) ov_fade_out.value = overlay.fade_out_ms ?? 0;
			if (ov_bg_trans) ov_bg_trans.checked = isTrans;
			if (ov_bg) {
				ov_bg.disabled = isTrans;
				ov_bg.value = isTrans ? '#000000' : (overlay.background || '#000000');
			}
			if (ov_bg_pickBtn) ov_bg_pickBtn.disabled = isTrans;
			if (ov_chip_bg) ov_chip_bg.value = overlay.chip_bg || '#000000';
			if (ov_chip_fg) ov_chip_fg.value = overlay.chip_fg || '#ffffff';
			if (ov_gap) ov_gap.value = overlay.chip_gap ?? 8;
			if (ov_pad_v) ov_pad_v.value = overlay.chip_pad_v ?? 10;
			if (ov_pad_h) ov_pad_h.value = overlay.chip_pad_h ?? 14;
			if (ov_radius) ov_radius.value = overlay.chip_radius ?? 10;
			if (ov_font_px) ov_font_px.value = overlay.chip_font_px ?? 24;
			if (ov_font_w) ov_font_w.value = overlay.chip_font_weight ?? 700;
			if (ov_cols) ov_cols.value = overlay.cols ?? 8;
			if (ov_rows) ov_rows.value = overlay.rows ?? 1;
			if (ov_align) ov_align.value = overlay.align || 'left';
			if (ov_direction) ov_direction.value = overlay.direction || 'ltr';
			
			if (ov_bg_pickBtn && ov_bg) setPickBtn(ov_bg_pickBtn, ov_bg.value);
			if (ov_chip_bg_pickBtn && ov_chip_bg) setPickBtn(ov_chip_bg_pickBtn, ov_chip_bg.value);
			if (ov_chip_fg_pickBtn && ov_chip_fg) setPickBtn(ov_chip_fg_pickBtn, ov_chip_fg.value);
			updatePreview();
			
			// Save to server with the imported overlay data directly
			await saveOverlayConfig({
				fade_in_ms: overlay.fade_in_ms ?? 0,
				fade_out_ms: overlay.fade_out_ms ?? 0,
				background: overlay.background || 'rgba(0,0,0,0)',
				chip_bg: overlay.chip_bg || '#000000',
				chip_fg: overlay.chip_fg || '#ffffff',
				chip_gap: overlay.chip_gap ?? 8,
				chip_pad_v: overlay.chip_pad_v ?? 10,
				chip_pad_h: overlay.chip_pad_h ?? 14,
				chip_radius: overlay.chip_radius ?? 10,
				chip_font_px: overlay.chip_font_px ?? 24,
				chip_font_weight: overlay.chip_font_weight ?? 700,
				cols: overlay.cols ?? 8,
				rows: overlay.rows ?? 1,
				align: overlay.align || 'left',
				direction: overlay.direction || 'ltr'
			});
		}

		gistExportBtn.addEventListener('click', async () => {
			const token = localStorage.getItem('github_token');
			if (!token) {
				alert(currentLanguage === 'ko' ? 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' : 'Login required');
				return;
			}
			const desc = gistExportDesc.value.trim() || 'KeyViewer Preset';
			const data = { 
				keyImages: { 
					individual: keyImagesData, 
					groups: keyGroupsData,
					allKeys: allKeysData
				},
				styleGroups: getStyleGroupsForExport(),
				overlay: getOverlayConfigForExport(),
				version: 3  // Bump version to 3 for style groups support
			};
			
			try {
				const response = await fetch('https://api.github.com/gists', {
					method: 'POST',
					headers: {
						'Authorization': `token ${token}`,
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						description: desc,
						public: false,
						files: {
							'keyviewer-preset.json': { content: JSON.stringify(data, null, 2) }
						}
					})
				});
				
				if (response.ok) {
					const result = await response.json();
					gistExportResult.style.display = 'block';
					gistExportResult.innerHTML = `${currentLanguage === 'ko' ? 'ì„±ê³µ! Gist ID:' : 'Success! Gist ID:'} <code style="background:#2a3040; padding:2px 6px; border-radius:4px">${result.id}</code>`;
				} else {
					throw new Error('Failed to create gist');
				}
			} catch (e) {
				alert(currentLanguage === 'ko' ? 'Gist ìƒì„± ì‹¤íŒ¨: ' + e.message : 'Failed to create gist: ' + e.message);
			}
		});

		gistImportBtn.addEventListener('click', async () => {
			const gistId = gistImportId.value.trim();
			if (!gistId) {
				alert(currentLanguage === 'ko' ? 'Gist IDë¥¼ ì…ë ¥í•˜ì„¸ìš”' : 'Please enter Gist ID');
				return;
			}
			
			try {
				const response = await fetch(`https://api.github.com/gists/${gistId}`);
				if (!response.ok) throw new Error('Gist not found');
				
				const result = await response.json();
				const file = result.files['keyviewer-preset.json'];
				if (!file) throw new Error('Invalid preset file');
				
				const data = JSON.parse(file.content);
				
				// Support both v1 (flat) and v2 (nested) formats
				if (data.version === 2) {
					// Version 2: nested format
					keyImagesData = data.keyImages?.individual || {};
					keyGroupsData = data.keyImages?.groups || [];
					if (data.overlay) {
						await applyImportedOverlayConfig(data.overlay);
					}
				} else {
					// Version 1: flat format (backward compatibility)
					keyImagesData = data.individual || {};
					keyGroupsData = data.groups || [];
				}
				
				saveKeyImagesToStorage();
				renderStyleGroupsList(); // Refresh style groups list
				alert(currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ! (í‚¤ ì´ë¯¸ì§€ + ì˜¤ë²„ë ˆì´ ì„¤ì •)' : 'Import successful! (Key images + Overlay settings)');
			} catch (e) {
				alert(currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + e.message : 'Import failed: ' + e.message);
			}
		});

		// JSON Export/Import
		jsonExportBtn.addEventListener('click', async () => {
			const data = { 
				keyImages: { 
					individual: keyImagesData, 
					groups: keyGroupsData,
					allKeys: allKeysData
				},
				styleGroups: getStyleGroupsForExport(),
				overlay: getOverlayConfigForExport(),
				version: 3  // Bump version to 3 for style groups support
			};
			const json = JSON.stringify(data, null, 2);
			try {
				await navigator.clipboard.writeText(json);
				alert(currentLanguage === 'ko' ? 'JSONì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! (í‚¤ ì´ë¯¸ì§€ + ìŠ¤íƒ€ì¼ ê·¸ë£¹ + ì˜¤ë²„ë ˆì´ ì„¤ì •)' : 'JSON copied to clipboard! (Key images + Style groups + Overlay settings)');
			} catch (e) {
				// Fallback: show in prompt
				prompt(currentLanguage === 'ko' ? 'JSONì„ ë³µì‚¬í•˜ì„¸ìš”:' : 'Copy the JSON:', json);
			}
		});

		// Helper function to process imported JSON data
		async function processImportedData(data) {
			if (data.version >= 3) {
				// Version 3+: includes style groups
				keyImagesData = data.keyImages?.individual || {};
				keyGroupsData = data.keyImages?.groups || [];
				allKeysData = data.keyImages?.allKeys || null;
				styleGroups = data.styleGroups || [];
				
				// Save to localStorage
				localStorage.setItem('keyviewer_style_groups', JSON.stringify(styleGroups));
				saveKeyImagesToStorage();
				
				if (data.overlay) {
					await applyImportedOverlayConfig(data.overlay);
				}
				renderStyleGroupsList();
				updateUnifiedPreview();
			} else if (data.version === 2) {
				// Version 2: nested format with overlay
				keyImagesData = data.keyImages?.individual || {};
				keyGroupsData = data.keyImages?.groups || [];
				allKeysData = data.keyImages?.allKeys || null;
				saveKeyImagesToStorage();
				if (data.overlay) {
					await applyImportedOverlayConfig(data.overlay);
				}
			} else {
				// Version 1: flat format (backward compatibility)
				keyImagesData = data.individual || {};
				keyGroupsData = data.groups || [];
				allKeysData = data.allKeys || null;
			}
			saveKeyImagesToStorage();
			renderStyleGroupsList(); // Refresh style groups list
		}

		jsonImportBtn.addEventListener('click', async () => {
			try {
				const json = await navigator.clipboard.readText();
				const data = JSON.parse(json);
				await processImportedData(data);
				alert(currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ! (í‚¤ ì´ë¯¸ì§€ + ì˜¤ë²„ë ˆì´ ì„¤ì •)' : 'Import successful! (Key images + Overlay settings)');
			} catch (e) {
				// Fallback: prompt input
				const json = prompt(currentLanguage === 'ko' ? 'JSONì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”:' : 'Paste JSON:');
				if (json) {
					try {
						const data = JSON.parse(json);
						await processImportedData(data);
						alert(currentLanguage === 'ko' ? 'ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ! (í‚¤ ì´ë¯¸ì§€ + ì˜¤ë²„ë ˆì´ ì„¤ì •)' : 'Import successful! (Key images + Overlay settings)');
					} catch (e2) {
						alert(currentLanguage === 'ko' ? 'JSON íŒŒì‹± ì‹¤íŒ¨: ' + e2.message : 'Failed to parse JSON: ' + e2.message);
					}
				}
			}
		});

		// ì–¸ì–´ ì„¤ì • ë¨¼ì € ë¡œë“œ (ë‹¤ë¥¸ ê²ƒë³´ë‹¤ ìš°ì„ )
		await loadLanguageSettings();
		console.log('âœ“ Language loaded:', currentLanguage);
		
		await Promise.all([refreshTarget(), loadWindows(), loadConfig(), loadForeground()]);
		updateHeaderArrows();
		Object.values(headerMap).forEach(th => {
			if (!th) return;
			safeAddEventListener(th, 'click', ()=> setSort(th.dataset.key));
		});
		updateDebugInfo();
		setInterval(loadWindows, 3000);
		setInterval(loadForeground, 1000);
		setInterval(loadLanguageSettings, 5000); // ì£¼ê¸°ì ìœ¼ë¡œ ì–¸ì–´ ì„¤ì • ê°±ì‹ 
	})();
	</script>
</body>
</html>