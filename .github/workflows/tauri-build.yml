name: Tauri Build and Release

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

# Optimize build speed with caching
# - Rust toolchain and dependencies are cached
# - Tauri CLI is cached to avoid reinstalling (saves ~3-5 minutes per build)
# - Linux apt packages are cached
# - All platform builds run in parallel

jobs:
  # Read version for all jobs
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Read version
      id: version
      run: |
        version=$(cat version.txt | tr -d '\n\r')
        echo "version=$version" >> $GITHUB_OUTPUT
        echo "Version: $version"

  # Windows Portable Build
  build-windows-portable:
    needs: prepare
    runs-on: windows-latest
    continue-on-error: true
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Rust cache
      uses: swatinem/rust-cache@v2
      with:
        workspaces: './src-tauri -> target'
        cache-on-failure: true

    - name: Cache Tauri CLI
      id: cache-tauri
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-tauri.exe
        key: ${{ runner.os }}-tauri-cli-2.0

    - name: Install Tauri CLI
      if: steps.cache-tauri.outputs.cache-hit != 'true'
      shell: pwsh
      run: cargo install tauri-cli --version "^2.0.0" --locked

    - name: Generate icon.png
      shell: pwsh
      run: |
        if (-not (Test-Path "src-tauri\icons\icon.png")) {
          .\convert-icon.ps1
        }

    - name: Build Windows Portable
      shell: pwsh
      run: |
        .\build-portable.ps1

    - name: Upload EXE artifact (standalone)
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: windows-portable-exe-${{ needs.prepare.outputs.version }}
        path: |
          dist/KBQV-Portable-*.exe
    
    - name: Upload ZIP artifact (with README)
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: windows-portable-zip-${{ needs.prepare.outputs.version }}
        path: |
          dist/KBQV-Portable-*.zip

  # Linux Build
  build-linux:
    needs: prepare
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Cache apt packages
      uses: actions/cache@v4
      id: cache-apt
      with:
        path: /var/cache/apt/archives
        key: ${{ runner.os }}-apt-${{ hashFiles('.github/workflows/tauri-build.yml') }}

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libgtk-3-dev \
          libwebkit2gtk-4.1-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev \
          patchelf \
          libx11-dev \
          libxdo-dev \
          libxcb1-dev 

    - name: Rust cache
      uses: swatinem/rust-cache@v2
      with:
        workspaces: './src-tauri -> target'
        cache-on-failure: true

    - name: Cache Tauri CLI
      id: cache-tauri
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-tauri
        key: ${{ runner.os }}-tauri-cli-2.0

    - name: Install Tauri CLI
      if: steps.cache-tauri.outputs.cache-hit != 'true'
      run: cargo install tauri-cli --version "^2.0.0" --locked

    - name: Ensure icon.png
      run: |
        if [ ! -f "src-tauri/icons/icon.png" ]; then
          sudo apt-get update && sudo apt-get install -y imagemagick
          convert -size 256x256 xc:blue -fill white -gravity center -pointsize 48 -annotate +0+0 "KV" src-tauri/icons/icon.png
        fi

    - name: Build Linux
      working-directory: src-tauri
      env:
        CARGO_INCREMENTAL: 1
      run: cargo tauri build

    - name: Upload AppImage artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: linux-appimage-${{ needs.prepare.outputs.version }}
        path: |
          src-tauri/target/release/bundle/appimage/*.AppImage

    - name: Upload Deb artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: linux-deb-${{ needs.prepare.outputs.version }}
        path: |
          src-tauri/target/release/bundle/deb/*.deb

  # macOS Build (with Code Signing)
  build-macos:
    needs: prepare
    runs-on: macos-latest
    continue-on-error: true
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Rust cache
      uses: swatinem/rust-cache@v2
      with:
        workspaces: './src-tauri -> target'
        cache-on-failure: true

    - name: Cache Tauri CLI
      id: cache-tauri
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-tauri
        key: ${{ runner.os }}-tauri-cli-2.0

    - name: Install Tauri CLI
      if: steps.cache-tauri.outputs.cache-hit != 'true'
      run: cargo install tauri-cli --version "^2.0.0" --locked

    - name: Import Code Signing Certificate
      if: ${{ env.MACOS_SIGNING_CERT != '' }}
      env:
        MACOS_SIGNING_CERT: ${{ secrets.MACOS_SIGNING_CERT }}
        MACOS_SIGNING_CERT_PWD: ${{ secrets.MACOS_SIGNING_CERT_PWD }}
      run: |
        # Create temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
        KEYCHAIN_PWD="build-$(date +%s)"
        
        echo "Creating temporary keychain..."
        security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
        
        # Decode and import certificate
        echo "Importing certificate..."
        echo "$MACOS_SIGNING_CERT" | base64 --decode > $RUNNER_TEMP/cert.p12
        security import $RUNNER_TEMP/cert.p12 -k "$KEYCHAIN_PATH" \
          -P "$MACOS_SIGNING_CERT_PWD" \
          -T /usr/bin/codesign \
          -T /usr/bin/security
        
        # Allow codesign to access the keychain
        security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
        
        # Add keychain to search list
        security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain
        
        # Verify certificate
        echo "Verifying certificate..."
        security find-identity -v -p codesigning "$KEYCHAIN_PATH"
        
        # Save keychain path for later steps
        echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
        echo "SIGNING_IDENTITY=KeyViewer Signing" >> $GITHUB_ENV
        
        # Cleanup temp file
        rm -f $RUNNER_TEMP/cert.p12

    - name: Build macOS
      env:
        CARGO_INCREMENTAL: 1
      run: cargo tauri build

    - name: Sign macOS App
      if: ${{ env.SIGNING_IDENTITY != '' }}
      run: |
        echo "Signing .app bundle..."
        for app in src-tauri/target/release/bundle/macos/*.app; do
          if [ -d "$app" ]; then
            echo "Signing: $app"
            codesign --force --deep --sign "$SIGNING_IDENTITY" "$app"
            echo "Verifying signature..."
            codesign --verify --verbose "$app"
          fi
        done
        
        echo "Signing .dmg..."
        for dmg in src-tauri/target/release/bundle/dmg/*.dmg; do
          if [ -f "$dmg" ]; then
            echo "Signing: $dmg"
            codesign --force --sign "$SIGNING_IDENTITY" "$dmg"
          fi
        done

    - name: Prepare dist folder
      run: |
        mkdir -p dist/macos
        cp -f src-tauri/target/release/bundle/dmg/*.dmg dist/macos/ || true
        # Copy .app bundle as zip to keep structure in a single file
        if compgen -G "src-tauri/target/release/bundle/macos/*.app" > /dev/null; then
          for app in src-tauri/target/release/bundle/macos/*.app; do
            name=$(basename "$app")
            zip -rq "dist/macos/${name%.app}.zip" "$app"
          done
        fi

    - name: Cleanup Keychain
      if: always()
      run: |
        if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
          security delete-keychain "$KEYCHAIN_PATH" || true
        fi

    - name: Upload DMG artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: macos-dmg-${{ needs.prepare.outputs.version }}
        path: |
          src-tauri/target/release/bundle/dmg/*.dmg

    - name: Upload App artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: macos-app-${{ needs.prepare.outputs.version }}
        path: |
          src-tauri/target/release/bundle/macos/*.app

    - name: Upload dist macos bundle
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: macos-dist-${{ needs.prepare.outputs.version }}
        path: |
          dist/macos/*

  release:
    needs: [prepare, build-windows-portable, build-linux, build-macos]
    runs-on: ubuntu-latest
    if: always() && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts
      continue-on-error: true

    - name: Check build results and create checklist
      id: check_builds
      run: |
        echo "Checking downloaded artifacts..."
        ls -R ./artifacts || echo "No artifacts directory"
        
        # Initialize checklist
        checklist=""
        
        # Check Windows Portable EXE
        if [ -d "./artifacts/windows-portable-exe-${{ needs.prepare.outputs.version }}" ] && [ "$(ls -A ./artifacts/windows-portable-exe-${{ needs.prepare.outputs.version }})" ]; then
          checklist="${checklist}- ✅ Windows Portable\n"
          echo "windows_portable=true" >> $GITHUB_OUTPUT
        else
          checklist="${checklist}- ❌ Windows Portable (Build Failed)\n"
          echo "windows_portable=false" >> $GITHUB_OUTPUT
        fi
        
        # Check Linux AppImage
        if [ -d "./artifacts/linux-appimage-${{ needs.prepare.outputs.version }}" ] && [ "$(ls -A ./artifacts/linux-appimage-${{ needs.prepare.outputs.version }})" ]; then
          checklist="${checklist}- ✅ Linux AppImage\n"
          echo "linux_appimage=true" >> $GITHUB_OUTPUT
        else
          checklist="${checklist}- ❌ Linux AppImage (Build Failed)\n"
          echo "linux_appimage=false" >> $GITHUB_OUTPUT
        fi
        
        # Check Linux Deb
        if [ -d "./artifacts/linux-deb-${{ needs.prepare.outputs.version }}" ] && [ "$(ls -A ./artifacts/linux-deb-${{ needs.prepare.outputs.version }})" ]; then
          checklist="${checklist}- ✅ Linux Deb Package\n"
          echo "linux_deb=true" >> $GITHUB_OUTPUT
        else
          checklist="${checklist}- ❌ Linux Deb Package (Build Failed)\n"
          echo "linux_deb=false" >> $GITHUB_OUTPUT
        fi
        
        # Check macOS DMG
        if [ -d "./artifacts/macos-dmg-${{ needs.prepare.outputs.version }}" ] && [ "$(ls -A ./artifacts/macos-dmg-${{ needs.prepare.outputs.version }})" ]; then
          checklist="${checklist}- ✅ macOS DMG\n"
          echo "macos_dmg=true" >> $GITHUB_OUTPUT
        else
          checklist="${checklist}- ❌ macOS DMG (Build Failed)\n"
          echo "macos_dmg=false" >> $GITHUB_OUTPUT
        fi
        
        # Check macOS App
        if [ -d "./artifacts/macos-app-${{ needs.prepare.outputs.version }}" ] && [ "$(ls -A ./artifacts/macos-app-${{ needs.prepare.outputs.version }})" ]; then
          checklist="${checklist}- ✅ macOS App Bundle\n"
          echo "macos_app=true" >> $GITHUB_OUTPUT
        else
          checklist="${checklist}- ❌ macOS App Bundle (Build Failed)\n"
          echo "macos_app=false" >> $GITHUB_OUTPUT
        fi
        
        # Save checklist (escape newlines for GitHub Actions)
        echo "checklist<<EOF" >> $GITHUB_OUTPUT
        echo -e "$checklist" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Changelog
      id: changelog
      run: |
        version="${{ needs.prepare.outputs.version }}"
        currentTag="v$version"
        
        # Find previous tag
        tags=$(git tag --sort=-version:refname | grep -v "^$currentTag$" | head -n 1)
        if [ ! -z "$tags" ]; then
            previousTag=$tags
            echo "Previous tag found: $previousTag"
            echo "previous_tag=$previousTag" >> $GITHUB_OUTPUT
            
            # Generate Full Changelog
            changelog="**Full Changelog**: https://github.com/${{ github.repository }}/compare/$previousTag...$currentTag"
            echo "full_changelog=$changelog" >> $GITHUB_OUTPUT
            echo "Generated changelog: $changelog"
        else
            echo "No previous tags found"
            echo "previous_tag=" >> $GITHUB_OUTPUT
            echo "full_changelog=" >> $GITHUB_OUTPUT
        fi

    - name: Force Update Tag
      run: |
        version="${{ needs.prepare.outputs.version }}"
        tagName="v$version"
        
        # Remove existing tag if it exists
        if git tag -l "$tagName" | grep -q "$tagName"; then
          echo "Removing existing tag: $tagName"
          git tag -d "$tagName" || true
          git push origin ":refs/tags/$tagName" || true
        fi
        
        # Create new tag
        echo "Creating new tag: $tagName"
        git tag "$tagName"
        git push origin "$tagName"
    
    - name: Prepare release files
      run: |
        mkdir -p ./release-files
        
        # Copy only successful builds
        # Windows Portable - EXE only (primary download)
        if [ -d "./artifacts/windows-portable-exe-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/windows-portable-exe-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        # Windows Portable - ZIP with README (optional)
        if [ -d "./artifacts/windows-portable-zip-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/windows-portable-zip-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        if [ -d "./artifacts/linux-appimage-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/linux-appimage-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        if [ -d "./artifacts/linux-deb-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/linux-deb-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        if [ -d "./artifacts/macos-dmg-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/macos-dmg-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        if [ -d "./artifacts/macos-app-${{ needs.prepare.outputs.version }}" ]; then
          cp -r ./artifacts/macos-app-${{ needs.prepare.outputs.version }}/* ./release-files/ || true
        fi
        
        echo "Release files prepared:"
        ls -lh ./release-files/

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.prepare.outputs.version }}
        name: KeyQueueViewer v${{ needs.prepare.outputs.version }}
        body: |
          ## English
          
          **Built with Rust + Tauri 2.0** - Lightweight (~10MB), fast, and secure keyboard overlay viewer for streaming.
          
          ### Downloads
          - **Windows**: `KBQV-Portable-*.exe` (Recommended - no extraction needed)
          - **Linux**: `*.AppImage` or `*.deb`
          - **macOS**: `*.dmg`
          
          ### Windows Users
          Administrator privileges are required for keyboard capture. Click "Yes" when UAC prompt appears.
          
          ### Quick Start
          1. Download and run the executable
          2. Click "Start Server"
          3. Add Browser Source in OBS with the provided URL
          4. Configure overlay settings as needed
          
          ---
          
          ## 한국어
          
          **Rust + Tauri 2.0 기반** - 가볍고 (~10MB) 빠른 스트리밍용 키보드 오버레이 뷰어
          
          ### 다운로드
          - **Windows**: `KBQV-Portable-*.exe` (권장 - 압축 해제 불필요)
          - **Linux**: `*.AppImage` 또는 `*.deb`
          - **macOS**: `*.dmg`
          
          ### Windows 사용자 필독
          키보드 캡처를 위해 관리자 권한이 필요합니다. UAC 창에서 "예"를 클릭하세요.
          
          ### 빠른 시작
          1. 실행 파일 다운로드 및 실행
          2. "서버 시작" 클릭
          3. OBS에서 브라우저 소스 추가 후 제공된 URL 입력
          4. 필요시 오버레이 설정 조정
          
          ---
          
          ### Build Status
          ${{ steps.check_builds.outputs.checklist }}
          
          ### Latest Changes
          ${{ github.event.head_commit.message }}
          
          ### Changelog
          ${{ steps.changelog.outputs.full_changelog }}
        files: |
          ./release-files/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

